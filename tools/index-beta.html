<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="google" content="notranslate">
    <script type="text/javascript" src="LZWEncoder.js"></script>
    <script type="text/javascript" src="NeuQuant.js"></script>
    <script type="text/javascript" src="GIFEncoder.js"></script>
    <script type="text/javascript" src="b64.js"></script>
    <title>Card maker</title>
    <style>
        html,body{
            margin:0;
            padding:0;
            width: 100%;
            height: 100%;
            background-color: #000;
            font-family: monospace;
            overflow: hidden;
        }
        
        #gifTools{
            position: absolute;
            right: 320px;
            top: 10px;
            display: flex;
            flex-direction: column;
            width: 85px;
        }

        #gifTools > *{
            float: left;
        }
        #gifTools > span{
            color: white;
            text-align: center;
        }

        #tools{
            position: absolute;
            width: 300px;
            height: 90%;
            background-color: #222;
            right: 10px;
            top: 10px;
            overflow-y: auto;
            overflow-x: hidden;
            
        }

        .group{
            width: 100%;
            height: fit-content;
            background-color: #333;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
        }
        .group > span{
            font-size: 16pt;
            width: 100%;
            text-align: center;
            color: aliceblue;
            border-bottom: solid 2px;
        }

        .group > span > button{
            float: right;
            margin: 2px;
            color: #003400;
            background-color: #009500;
            border: solid 2px #005800;
            border-radius: 5px;
        }

        input[type="color"]{
            padding: 0;
            background-color: transparent;
            border: 0;
        }
        .group > span > input[type="color"]{
            float:right;
        }

        .group > .tool-holder{
            width: 100%;
            height: fit-content;
            grid-auto-flow: dense;
            display: grid;
            grid-template-columns: 240px 60px;
            grid-template-rows: 20px 20px 20px;
        }
        
        .group > .tool-holder *[color]{
            grid-column: 1;
            border: solid 1px #000;
        }

        .group > .tool-holder *[color="preview"]{
            grid-column: 2;
            grid-row: span 3;
            width: 60px;
            height: 60px;
            border: solid 2px;
            padding: 0;
        }

        .text{
            color: white;
        }

        *::-webkit-scrollbar{
            width: 8px;
        }
        *::-webkit-scrollbar-thumb{
            background: #afafaf;
        }

        .group#shapes > div:nth-child(n+3),
        .group#vars > div:nth-child(n+3),
        .group#texts > div:nth-child(n+3){
            border-top: solid 2px white;
        }

        .group#shapes > div > div:nth-child(2n),
        .group#vars > div > div:nth-child(2n),
        .group#texts > div > div:nth-child(2n){
            background-color: rgba(0, 0, 0, 0.158);
        }

        .group#shapes > div.hidden > div:not(.topbar),
        .group#vars > div.hidden > div:not(.topbar),
        .group#texts > div.hidden > div:not(.topbar){
            display: none;
        }

        .group#vars > div > div.topbar,
        .group#texts > div > div.topbar{
            height: 25px;
        }

        .group > div > div.topbar > button{
            float: right;
            margin: 2px;
        }

        .group button.close{
            color: black;
            background-color: #c50000;
            border: solid 2px #620000;
            border-radius: 5px;
        }
        .group button.pasive{
            color: black;
            background-color: #d1d1d1;
            border: solid 2px #797979;
            border-radius: 5px;
        }

        .orange,
        .cbdrw{
            background-color: #c55f00;
            border: solid 2px #623b00;
            border-radius: 5px;
        }

        .green,
        .cbdrw.isdrawing{
            background-color: #69c500;
            border: solid 2px #106200;
            border-radius: 5px;
        }

        :is(.group#texts, .group#vars, .group#shapes) > div > div{
            color: white;
            contain: layout;
        }

        :is(.group#texts,.group#vars, .group#shapes) > div > div > *:is(input, textarea, select){
            width:60%;
            float: right;
        }

        .group > div select{
            margin-top: 4px;
        }

        :is(.group#texts, .group#shapes) > div > div > textarea{
            width:85%;
            resize: vertical;
        }

        :is(.group#texts,.group#vars, .group#shapes) > div > div > input:not([type="color"]){
            margin-top:4px;
        }

        .group#vars .dbld{
            background-color: #b16a00;
            border: solid 2px #623b00;
        }

        .group a{
            color: white;
        }

        .group.hidden > *:not([aot]){
            display: none;
        }

        .group.hidden > *[aot] #tovi{
            background-color: #c55f00;
            border: solid 2px #623b00;
        }

        div.colortip{
            float: right;
            margin: 0;
            border: solid 2px #505050;
            background: #707070;
            color: white;
            height: 13px;
            margin-top: 4px;
            width: 13px;
            padding: 1px 1px 1px 1px;
            font-size: 13px;
            text-align: center;
            line-height: 13px;
        }

        button.colortip{
            float: right;
            margin: 0;
            border: solid 2px #505050;
            background: #707070;
            color: white;
            height: 19px;
            margin-top: 4px;
            width: 19px;
            line-height: 1px;
            padding: 1px 1px 1px 1px;
        }

        * > div.tiplist{
            display: none;
        }

        *:hover > div.tiplist{
            display: unset;
        }

        div.tiplist{
            position: absolute;
            right: 19px;
            top: 0;
            margin-top: 4px;
            background-color: #222;
        }
        div.tiplist > *{
            margin-right: 5px;
            margin-top: 0;
        }

        .contextMenu{
            width: 350px;
            min-height: 30px;
            max-height: 400px;
            overflow-y: auto;
            background-color: rgb(51, 51, 51);
            position: absolute;
        }

        .contextMenu .contextMenuBtn{
            width: 100%;
            height: 30px;
            background-color: #555;
            color: white;
        }

        .contextMenu .contextMenuBtn:hover{
            background-color: #666;
        }

        .contextMenu input.contextMenuBtn{
            width: 50%;
        }

        .screenCenter{
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		.canvasLayout{
			position: absolute;
			bottom: 66px;
			top: 34px;
			width: 100%;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
		}

		.canvasLayout > canvas{
			max-width: 100%;
    		max-height: 100%;
			border: solid 2px #000;
		}

		.paintTopBar{
			padding: 5px;
			height: 22px;
			border-bottom: solid 2px #fff;
		}

		.paintTopBar > *{
			float:  right;
			margin-left: 10px;
		}

		.paintToolBar{
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			padding: 5px;
			height: 54px;
			border-top: solid 2px #fff;
		}

		.colorPickerLayout{
			float: left;
			display: flex;
			flex-direction: column;
			height: 100%;
			width:50%;
			flex-wrap: wrap;
			align-content: flex-start;
		}
        
        .colorPickerLayout > input[type='color']{
            background: transparent!important;
        }
		

		.colorSlot{
			width: 20px;
			height: 20px;
			padding: 0;
			margin: 2px;
			border: solid 1px black;
			background-color: #fff;
		}

    </style>
</head>
<body>
    <a id="link"></a>
    <canvas id="c"></canvas>
    <div id="tools">
        <div class="group" id="colors">
            <span aot>Colors <button onclick="addColor(this.parentNode.parentNode)">+</button><button id="tovi" onclick="toggleClass(this.parentNode.parentNode, 'hidden')">V</button></span>
        </div>
        <div class="group" id="texts">
            <span aot>Texts <button onclick="addText(this.parentNode.parentNode)">+</button><button id="tovi" onclick="toggleClass(this.parentNode.parentNode, 'hidden')">V</button></span>
        </div>
        <div class="group" id="vars">
            <span aot>Vars <button onclick="addVar(this.parentNode.parentNode, null, 'c')">C</button><button onclick="addVar(this.parentNode.parentNode, null, 't')">T</button><button id="tovi" onclick="toggleClass(this.parentNode.parentNode, 'hidden')">V</button></span>
        </div>
        <div class="group" id="shapes">
            <span aot>Shapes <!--<button onclick="addShape(this.parentNode.parentNode)">+</button>--><button id="tovi" onclick="toggleClass(this.parentNode.parentNode, 'hidden')">V</button></span>
            <select oninput="addShape(this.parentNode, -1, -1, this.value); this.value = '...';redrawTiles()">
                <option value="...">...</option>
                <option value="ci">Circle</option>
                <option value="re">Rect</option>
                <option value="im">Image</option>
                <option value="dr">Drawing (Experimental)</option>
                <option value="iim">Included image</option>
                <option value="larc">L Circle</option>
                <option value="lrect">L Rect</option>
            </select>
        </div>
        <div class="group" id="tiles">
            <span aot>Tiles <button id="tovi" onclick="toggleClass(this.parentNode.parentNode, 'hidden')">V</button></span>
            <input id="th" onchange="newTiles(1, this.value = inRange(this.min, this.max, this.value))" min="1" max="50" type="number" value="12" title="tiles per row" placeholder="tiles per row">
            <input id="tw" onchange="newTiles(0, this.value = inRange(this.min, this.max, this.value))" min="1" max="30" type="number" value="9" title="tiles per column" placeholder="tiles per column">
            <input id="tou" onchange="ou = this.value = inRange(this.min, this.max, this.value); redrawTiles();" min="0" max="10" type="number" value="2" title="tile outline" placeholder="tile outline">
            <input id="tsw" onchange="tileW = this.value = inRange(this.min, this.max, this.value); redrawTiles();" min="1" max="500" type="number" value="46" title="tile width" placeholder="tile width">
            <input id="tsh" onchange="tileH = this.value = inRange(this.min, this.max, this.value); redrawTiles();" min="1" max="500" type="number" value="46" title="tile height" placeholder="tile height">
        </div>
        <div class="group">
            <span>File</span>
            <input id="fna" onchange="filename = this.value" placeholder="file name">
            <button onclick="save()">Export</button>
            <input type="file" id="import" onchange="imported(this)" placeholder="import a file">
            <div class="text">Save with outer outlines: <input id="outl" onchange="outerOutline = this.checked" type="checkbox"></div>
            <button onclick="saveImage()">Save image</button>
        </div>
        <div class="group">
            <span>links</span>
            <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?v=ezdL9y9WN6c">Guide - video by awen</a>
            <a target="_blank" rel="noopener noreferrer" href="./guide.html">Other info (ugly web page!)</a>
        </div>
    </div>
    <div id="gifTools">
        <span vv="title">Gifs</span>
        <button vv="beginBtn">Reset</button>
        <button vv="add">Add frame</button>
        <input vv="fps" type="number" placeholder="30 (1 - 60)" title="frames per second">
        <input vv="repeatCnt" type="number" placeholder="0" title="0 - no limit">
        <button vv="save">save</button>
        
    </div>

    <script>
        document.createElementP = function(name, args = null, fnc=null, parent = null){
			const element = document.createElement(name)
			if(parent) parent.appendChild(element);
            if(args != null)Object.assign(element,args);
            if(args && args.style)Object.keys(args.style).forEach(e=>{element.style[e] = args.style[e]});
            if(fnc) fnc(element);
            return element;
        }

        if (!String.prototype.format) {
            String.prototype.format = function() {
                let args = arguments;
                return this.replace(/{(\d+)}/g, function(match, number) { 
                    return typeof args[number] != 'undefined'
                    ? args[number]
                    : match
                    ;
                });
            };
        }
        if(!String.prototype.insertAt){
            String.prototype.insertAt = function(v,n=-1){
                if(n == -1) n = this.length;
                return this.slice(0,n)+v+this.slice(n);
            }
        }

        const canvas = document.getElementById("c");
        let ctx = canvas.getContext("2d");
        const tools = document.getElementById("tools");
        
        let ou = 2, tileW = 46, tileH = 46, scale = 1, tscale = 1, off = 10;
        
        let tiledPos = (x,y)=>[off + (x) * tileW+ ou*3+ou*2*(x), off + (y) * tileH+ ou*3+ou*2*(y)];

        let w = canvas.width = window.innerWidth;
        let h = canvas.height = window.innerHeight;

        let toolInfo = {a:"set", v:0, cpc:"#000000"},
        filename = "",
        outerOutline=false;

        const localReources = {
            images:['100-gem', '1000-gem', '250-gem', '50-gem', '500-gem', '750-gem', 'area-50',
                'atonement', 'attract', 'autumn-wreath', 'backtrack', 'bandages', 'barrier', 'black_hole',
                'bloom', 'blue-flames', 'blue-santa-hat', 'bronze-crown', 'charge', 'crumble', 'decay',
                'depart', 'distort', 'earthquake', 'ember', 'energize', 'flames', 'flashlight_item',
                'flashlight', 'flow', 'fusion', 'gold-crown', 'gold-wreath', 'halo', 'harden', 'latch',
                'lightning', 'magnetism', 'minimize', 'mortar', 'night', 'obscure', 'olympics-wreath',
                'orbit-ring', 'orbit', 'paralysis', 'pollinate', 'pumpkin_off_healing', 'pumpkin_off',
                'pumpkin_on_healing', 'pumpkin_on', 'radioactive_gloop', 'reanimate', 'repel',
                'resurrection', 'reverse', 'rewind', 'santa-hat', 'shadow', 'shatter', 'shift', 'shriek',
                'silver-crown', 'snowball_projectile', 'snowball', 'spark', 'spring-wreath', 'stars',
                'sticky_coat', 'sticky-coat', 'stomp', 'stream', 'sugar_rush', 'summer-wreath', 'supernova',
                'sweet_tooth_item', 'sweet_tooth', 'torch', 'toxic-coat', 'vengeance_projectile',
                'vengeance', 'vigor', 'warp', 'wildfire', 'winter-wreath', 'wormhole'],
            _images:{},
        }
        for(let i in localReources.images){
            let img = new Image();
            img.src = `./images/${localReources.images[i]}.png`;
            img.onload = ()=>{
                localReources._images[localReources.images[i]] = img;
            }
        }
        
        window.onresize = ()=>{
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            tools.style.height = parseInt(window.innerHeight) - 20 + "px";
            redrawTiles();
        }

        function inRange(min,max,val){return Math.min(max,Math.max(min,val))}

        const colorHelpTip = 
        `<div class="colortip">?
            <div class="tiplist">
                <button class="colortip" onclick="let o = Object.values(this.parentNode.parentNode.parentNode.children).find(e=>e.tagName=='INPUT');toolInfo.cpc = o.value;copyToClipboard(o.value)">C</button>
                <button class="colortip" onclick="let o = Object.values(this.parentNode.parentNode.parentNode.children).find(e=>e.tagName=='INPUT');o.value = toolInfo.cpc; o.oninput()">P</button>
            </div>
        </div>`

        let types = [];
        let currentTi = 0;
        let currentSi = 0;
        let texts = {};
        let shapes = {};
        let moving = {};
        let varsC = {
            data:{},
            dataC:{},
            varsC:{},
            varsCp:{},
            currentVi:0,
            vars:{},
            varsp:{
                "magmax":"<c=red><oc=darkred>{0}</oc></c>",
                "rime":"<c=#3333ff><oc=#1111aa>{0}</oc></c>",
                "morfe":"<c=#00dd00><oc=#007700>{0}</oc></c>",
                "aurora":"<c=#ff7f18><oc=#b85a0f>{0}</oc></c>",
                "necro":"<c=#ff00ff><oc=#b300b3>{0}</oc></c>",
                "brute":"<c=#9b5800><oc=#6e3e00>{0}</oc></c>",
                "nexus":"<c=#29ffc6><oc=#189e7a>{0}</oc></c>",
                "shade":"<c=#826565><oc=#544141>{0}</oc></c>",
                "euclid":"<c=#5e4d66><oc=#3d3142>{0}</oc></c>",
                "chrono":"<c=#00b271><oc=#007047>{0}</oc></c>",
                "reaper":"<c=#424a59><oc=#2d323d>{0}</oc></c>",
                "rameses":"<c=#989b4a><oc=#676932>{0}</oc></c>",
                "jolt":"<c=#e1e100><oc=#a1a100>{0}</oc></c>",
                "ghoul":"<c=#bad7d8><oc=#7f9899>{0}</oc></c>",
                "cent":"<c=#727272><oc=#545454>{0}</oc></c>",
                "jotunn":"<c=#5cabff><oc=#3e77b3>{0}</oc></c>",
                "candy":"<c=#ff80bd><oc=#bd5c8b>{0}</oc></c>",
                "mirage":"<c=#020fa2><oc=#020c75>{0}</oc></c>",
                "boldrock":"<c=#a18446><oc=#735e31>{0}</oc></c>",
                
                "magmaxg":"<sc=red><var=magmax;{0}></sc>",
                "rimeg":"<sc=#3333ff><var=rime;{0}></sc>",
                "morfeg":"<sc=#00dd00><var=morfe;{0}></sc>",
                "aurorag":"<sc=#ff7f18><var=aurora;{0}></sc>",
                "necrog":"<sc=#ff00ff><var=necro;{0}></sc>",
                "bruteg":"<sc=#9b5800><var=brute;{0}></sc>",
                "nexusg":"<sc=#29ffc6><var=nexus;{0}></sc>",
                "shadeg":"<sc=#826565><var=shade;{0}></sc>",
                "euclidg":"<sc=#5e4d66><var=euclid;{0}></sc>",
                "chronog":"<sc=#00b271><var=chrono;{0}></sc>",
                "reaperg":"<sc=#424a59><var=reaper;{0}></sc>",
                "ramesesg":"<sc=#989b4a><var=rameses;{0}></sc>",
                "joltg":"<sc=#e1e100><var=jolt;{0}></sc>",
                "ghoulg":"<sc=#bad7d8><var=ghoul;{0}></sc>",
                "centg":"<sc=#727272><var=cent;{0}></sc>",
                "jotunng":"<sc=#5cabff><var=jotunn;{0}></sc>",
                "candyg":"<sc=#ff80bd><var=candy;{0}></sc>",
                "mirageg":"<sc=#020fa2><var=mirage;{0}></sc>",
                "boldrockg":"<sc=#a18446><var=boldrock;{0}></sc>",
                
                "wreath":"<c=yellow><oc=#aa0>{0}</c></oc>",
                "wreathg":"<sc=yellow><var=wreath;{0}></sc>",
                "bi":"<b><i>{0}</i></b>",
                //enemies
                "wall": "<c=#222222>{0}</c>",
                "normal": "<c=#939393>{0}</c>",
                "homing": "<c=#966e14>{0}</c>",
                "dasher": "<c=#003c66>{0}</c>",
                "slowing": "<c=#ff0000>{0}</c>",
                "experience_drain": "<c=#b19cd9>{0}</c>",
                "enlarging": "<c=#4d0163>{0}</c>",
                "draining": "<c=#0000ff>{0}</c>",
                "gravity": "<c=#78148c>{0}</c>",
                "repelling": "<c=#7b9db2>{0}</c>",
                "turning": "<c=#336600>{0}</c>",
                "sizing": "<c=#f27743>{0}</c>",
                "sniper": "<c=#a05353>{0}</c>",
                "freezing": "<c=#64c1b9>{0}</c>",
                "teleporting": "<c=#ecc4ef>{0}</c>",
                "wavy": "<c=#dd2606>{0}</c>",
                "zigzag": "<c=#b371f2>{0}</c>",
                "zoning": "<c=#a03811>{0}</c>",
                "spiral": "<c=#e8b500>{0}</c>",
                "oscillating": "<c=#869e0f>{0}</c>",
                "switch": "<c=#565656>{0}</c>",
                "liquid": "<c=#6789ef>{0}</c>",
                "icicle": "<c=#adf8ff>{0}</c>",
                "slippery": "<c=#1aacbf>{0}</c>",
                "ice_sniper": "<c=#8300ff>{0}</c>",
                "disabling": "<c=#a87c86>{0}</c>",
                "speed_sniper": "<c=#ff9000>{0}</c>",
                "regen_sniper": "<c=#00cc8e>{0}</c>",
                "radiating_bullets": "<c=#d3134f>{0}</c>",
                "immune": "<c=#000000>{0}</c>",
                "pumpkin": "<c=#e26110>{0}</c>",
                "tree": "<c=#4e2700>{0}</c>",
                "frost_giant": "<c=#7e7cd6>{0}</c>",
                "snowman": "<c=#ffffff>{0}</c>",
                "corrosive": "<c=#00eb00>{0}</c>",
                "toxic": "<c=#00c700>{0}</c>",
                "corrosive_sniper": "<c=#61ff61>{0}</c>",
                "poison_sniper": "<c=#8c01b7>{0}</c>",
                "magnetic_reduction": "<c=#bd67d2>{0}</c>",
                "magnetic_nullification": "<c=#642374>{0}</c>",
                "positive_magnetic_sniper": "<c=#ff3852>{0}</c>",
                "negative_magnetic_sniper": "<c=#a496ff>{0}</c>",
                "residue": "<c=#675327>{0}</c>",
                "fire_trail": "<c=#cf5504>{0}</c>",
                "ice": "<c=#be89ff>{0}</c>"
            },
            generate: function(){
                this.vars = {...this.varsp};
                this.varsC = {...this.varsCp};
                let dbtkys = [];
                
                for(let key in this.data){
                    if(this.data[key].hid) continue;
                    if(this.data[key].k in this.vars) dbtkys.push(this.data[key].k)
                    this.vars[this.data[key].k] = this.data[key].v;
                }
                for(let key in this.dataC){
                    if(this.dataC[key].hid) continue;
                    if(this.dataC[key].k in this.varsC) dbtkys.push(this.dataC[key].k)
                    this.varsC[this.dataC[key].k] = this.dataC[key].v;
                }
                document.querySelectorAll(`[varkey]>[vv="key"]>input`).forEach((e)=>{
                    if(dbtkys.includes(e.value)){
                        e.classList.contains("dbld")||e.classList.add("dbld");
                    }else{
                        e.classList.contains("dbld")&&e.classList.remove("dbld");
                    }
                })
                
            },
            add: function(d, idx = -1){
                let data = d.t == "c" ? this.dataC:this.data;
                data[idx != -1? idx : (this.currentVi++)] = d;
                return [d, idx != -1? idx : (this.currentVi-1)];
                this.generate();
            },
            remove: function(k, t){
                delete (t== "c" ? this.dataC : this.data)[k];
                this.generate();
            },
            editk:function(i,v, t){
                (t== "c" ? this.dataC : this.data)[i].k = v;
                this.generate();
            },
            editv:function(i,v, t){
                (t== "c" ? this.dataC : this.data)[i].v = v;
                this.generate();
            },
            edith:function(i,v, t){
                (t== "c" ? this.dataC : this.data)[i].hid = v;
                this.generate();
            },
            restore: function(){
                this.vars = {...this.varsp};
                this.varC = {...this.varsCp};
                this.data = {};
                this.dataC = {};
                this.generate();
            },
        };
        varsC.generate();

        let tiles = [
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0],
        ];

        const tilescnt = [tiles.length, tiles[0].length];
        function newTiles(d, v){
            if(isNaN(v = parseInt(v)))return;
            tilescnt[d] = v;
            if(d == 0){
                if(tiles.length > v){
                    tiles.length = v;
                }else
                if(tiles.length < v){
                    for(let i = tiles.length; i < v; i++){
                        tiles.push(new Array(tilescnt[1]).fill(0));
                    }
                }
            }else{
                if(tiles[0].length > v){
                    for(let i = 0; i < tilescnt[0]; i++){
                        tiles[i].length = v;
                    }
                }else
                if(tiles[0].length < v){
                    for(let i = 0; i < tilescnt[0]; i++){
                        for(let j = tiles[i].length; j < v; j++){
                            tiles[i].push(0);
                        }
                    }
                }
            }
            redrawTiles();
        }

        window.onresize();
        
        function drawShape(shape){
            if(shape.hid)return;
            
            ctx.closePath();
            let offs = (off-10)* (tscale);
            let posX = shape.x == "center" ? tiledPos(tiles[0].length/2, 0)[0] : shape.x.endsWith("tl") ? tiledPos(parseFloat(shape.x)-0.5, 0)[0] : ((parseFloat(shape.x))* tscale+offs),
            posY = shape.y == "center" ? tiledPos(0, tiles.length/2)[1] : shape.y.endsWith("tl") ? tiledPos(0, parseFloat(shape.y)-0.5)[1] : ((parseFloat(shape.y))* tscale+offs);
            
            if(shape.shape == "ci"){
                if(shape.ou > 0){
                    ctx.beginPath();
                    ctx.arc(posX, posY, (+(shape.ra)+ +(shape.ou)/2-1)*tscale, 0, Math.PI*2);
                    //ctx.fillStyle = shape.b;
                    ctx.strokeStyle = shape.b;
                    ctx.lineWidth = shape.ou;
                    ctx.stroke();
                    ctx.closePath();
                }
                
                ctx.beginPath();
                ctx.arc(posX, posY, shape.ra*tscale, 0, Math.PI*2);
                ctx.fillStyle = shape.f;
                ctx.fill();
                ctx.closePath();
            }else
            if(shape.shape == "re"){

                let wi = shape.wi.endsWith("w") ? parseFloat(shape.wi.slice(0,shape.wi.length-1)) * tileW : shape.wi.endsWith("h") ? parseFloat(shape.wi.slice(0,shape.wi.length-1)) * tileH : parseFloat(shape.wi),
                    he = shape.he.endsWith("w") ? parseFloat(shape.he.slice(0,shape.wi.length-1)) * tileW : shape.he.endsWith("h") ? parseFloat(shape.he.slice(0,shape.he.length-1)) * tileH : parseFloat(shape.he);

                let x = posX - +wi/2,
                    y = posY - +he/2,
                    w = +wi*tscale,
                    h = +he*tscale,
                    angle = shape.ang / 180 * Math.PI;
                ctx.translate(x+w/2, y+h/2)
                ctx.rotate(angle);
                
                ctx.beginPath();
                ctx.rect(-w/2, -h/2, w, h);
                if(shape.ou > 0){
                    ctx.strokeStyle = shape.b;
                    ctx.lineWidth = shape.ou;
                    ctx.lineJoin = shape.out;
                    ctx.stroke();
                }
                ctx.fillStyle = shape.f;
                ctx.fill();
                ctx.closePath();

                ctx.rotate(-angle);
                ctx.translate(-x-w/2, -y-h/2);
            }else
            if(shape.shape == "im" || shape.shape == "iim" || shape.shape == "dr"){//imagem.els
                
                let srcImg = shape.img;
                if(shape.shape == "iim"){
                    srcImg = localReources._images[shape.lin];
                    if(!srcImg)return;
                }

                let wi = shape.wi.endsWith("w") ? parseFloat(shape.wi.slice(0,shape.wi.length-1)) * tileW : shape.wi.endsWith("h") ? parseFloat(shape.wi.slice(0,shape.wi.length-1)) * tileH : shape.wi.endsWith("%") ? parseFloat(shape.wi.slice(0,shape.wi.length-1)) * (srcImg && srcImg.width || 100)/100 : parseFloat(shape.wi),
                he = shape.he.endsWith("w") ? parseFloat(shape.he.slice(0,shape.wi.length-1)) * tileW : shape.he.endsWith("h") ? parseFloat(shape.he.slice(0,shape.he.length-1)) * tileH : shape.he.endsWith("%") ? parseFloat(shape.he.slice(0,shape.he.length-1)) * (srcImg && srcImg.height || 100)/100 : parseFloat(shape.he);
                
                let x = posX - +wi/2,
                y = posY - +he/2,
                w = +wi*tscale,
                h = +he*tscale,
                angle = shape.ang / 180 * Math.PI;
                ctx.translate(x+w/2, y+h/2)
                ctx.rotate(angle);
                
                ctx.beginPath();
                ctx.globalAlpha = shape.alp;
                if(srcImg && srcImg.src){
                    ctx.scale(shape.flip ? -1:1, shape.flop ? -1:1);
                    ctx.drawImage(srcImg, -w/2, -h/2, w, h);
                    ctx.scale(shape.flip ? -1:1, shape.flop ? -1:1);
                
                }
                else {
                    ctx.rect(-w/2, -h/2, w, h);
                    ctx.fillStyle = "white"
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.closePath();

                ctx.rotate(-angle);
                ctx.translate(-x-w/2, -y-h/2);
            }
        }

        function drawTile(tile){
            if(!types[tile.type] || types[tile.type].f[1] == -1) return;
            if(types[tile.type].b[1] != -1){
                ctx.beginPath();
                ctx.rect(off + (tile.x) * tileW+ ou*3+ou*2*tile.x, off + (tile.y) * tileH+ ou*3+ou*2*tile.y, tileW+ou*2, tileH+ou*2);
                ctx.fillStyle = getColor(types[tile.type].b);
                ctx.fill();
                ctx.closePath();
            }

            ctx.beginPath();
            ctx.rect(off + (tile.x) * tileW+ ou*4+ou*2*tile.x, off + (tile.y) * tileH+ ou*4+ou*2*tile.y, tileW, tileH);
            ctx.fillStyle = getColor(types[tile.type].f);
            ctx.fill();
            ctx.closePath();
        }

        function redrawTiles(){
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, w, h);
            /*
            ctx.rect(0, 0, w, h);
            ctx.fillStyle="#000";
            ctx.fill();*/
            for(let i = 0; i < tiles.length; i++){
                for(let j = 0; j < tiles[i].length; j++){
                    drawTile({x:j, y:i, type:tiles[i][j]})
                }
            }
            for(let i in shapes){
                if(shapes[i].texto == 0){
                    if(shapes[i].shape == "larc" || shapes[i].shape == "lrect"){
                        tryMask(shapes[i])
                    }else
                        drawShape(shapes[i]);
                }
            }
            ctx.lineJoin = "round";
            for(let i in texts){
                drawText(texts[i]);
            }
            for(let i in shapes){
                if(shapes[i].texto == 1){
                    if(shapes[i].shape == "larc" || shapes[i].shape == "lrect"){
                        tryMask(shapes[i])
                    }else
                        drawShape(shapes[i]);
                }
            }
            /**tryMask({
                type: "larc",
                x: 200,
                y: 100,
                rad: 50*4,
                color: "#0000aa",
                alpha: 1,
                outerRad: 50*4//25*4,
            });*//*
            tryMask({
                type: "lrect",
                x: 500,
                y: 100,
                width: 100,
                height: 200,
                color: "#00aa00",
                alpha: 1,
                outerRad: 100*4,
            });*/
        }

        redrawTiles();

        function tryMask(objToDrawR){
            if(objToDrawR.hid)return;
            let offs = (off-10)* (tscale);
            let posX = objToDrawR.x == "center" ? tiledPos(tiles[0].length/2, 0)[0] : objToDrawR.x.endsWith("tl") ? tiledPos(parseFloat(objToDrawR.x)-0.5, 0)[0] : ((parseFloat(objToDrawR.x))* tscale+offs),
            posY = objToDrawR.y == "center" ? tiledPos(0, tiles.length/2)[1] : objToDrawR.y.endsWith("tl") ? tiledPos(0, parseFloat(objToDrawR.y)-0.5)[1] : ((parseFloat(objToDrawR.y))* tscale+offs);
            let objToDraw = {
                type: objToDrawR.shape,
                x: parseInt(posX),
                y: parseInt(posY),
                width: parseInt(objToDrawR.wi),
                height: parseInt(objToDrawR.he),
                rad: parseFloat(objToDrawR.ra)*4,
                outerRad: parseFloat(objToDrawR.ou)*4,
                color: objToDrawR.f,
                alpha: parseInt(objToDrawR.f.slice(7) || "ff", 16)/255,
            }

            let color = objToDraw.color.slice(1);
            color = [color.slice(0,2), color.slice(2,4), color.slice(4,6)].map(e=>parseInt(e, 16));

            let canvasWidth = canvas.width;
            let canvasHeight = canvas.height;

            let id = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            let pixels = id.data;
            function valueInPrc (v1,v2,prc, maxPrc = 1){
                prc = Math.max(Math.min(prc, 1), 0) * maxPrc;
                return (v1 * prc) + (v2 * (1-prc));
            }

            function getDistance(x1, y1, x2, y2){
                let y = x2 - x1;
                let x = y2 - y1;
                
                return Math.sqrt(x * x + y * y);
            }
            let max = tiledPos(tiles[0].length, tiles.length);

            if(objToDraw.type == "larc"){
                let middleX = (objToDraw.x)*4, middleY = (objToDraw.y)*4,
                    startX = Math.max(0, objToDraw.x - objToDraw.rad/4)*4, startY = Math.max(0, objToDraw.y - objToDraw.rad/4)*4,
                    endX = Math.min(Math.min(max[0], canvasWidth),objToDraw.x + objToDraw.rad/4)*4, endY = Math.min(Math.min(max[1], canvasHeight),objToDraw.y + objToDraw.rad/4)*4;
                
                for(let y = startY; y < endY; y +=4){
                    for(let x = startX; x < endX; x += 4){
                        let off = (y * canvasWidth + x);
                        let dist = getDistance(middleX, middleY, x,y);
                        if(dist < objToDraw.rad){
                            let prc = (objToDraw.rad - dist) / objToDraw.outerRad;
                            pixels[off] = valueInPrc(color[0], pixels[off], prc, objToDraw.alpha);
                            pixels[off + 1] = valueInPrc(color[1], pixels[off+1], prc, objToDraw.alpha);
                            pixels[off + 2] = valueInPrc(color[2], pixels[off+2], prc, objToDraw.alpha);
                            pixels[off + 3] = 255;
                        }
                    }
                }

            }else
            if(objToDraw.type == "lrect"){
                let startX = Math.max(0,objToDraw.x)*4, startY = Math.max(0,objToDraw.y)*4,
                    endX = Math.min(Math.min(max[0], canvasWidth),objToDraw.x + objToDraw.width)*4, endY = Math.min(Math.min(max[1], canvasHeight),objToDraw.y + objToDraw.height)*4,
                    middleX = (objToDraw.x + objToDraw.width/2)*4, middleY = (objToDraw.y + objToDraw.height/2)*4;
                
                
                for(let y = startY; y < endY; y +=4){
                    for(let x = startX; x < endX; x += 4){
                        let off = (y * canvasWidth + x);
                        
                        let distFromTop = y-objToDraw.y*4;
                        let distFromBottom = (objToDraw.y + objToDraw.height)*4-y;
    
                        let distFromLeft = x-objToDraw.x*4;
                        let distFromRight = (objToDraw.x + objToDraw.width)*4-x;
    
                        let prc = Math.min(distFromTop, distFromBottom, distFromLeft, distFromRight) / objToDraw.outerRad;
                        pixels[off] = valueInPrc(color[0], pixels[off], prc, objToDraw.alpha);
                        pixels[off + 1] = valueInPrc(color[1], pixels[off+1], prc, objToDraw.alpha);
                        pixels[off + 2] = valueInPrc(color[2], pixels[off+2], prc, objToDraw.alpha);
                        pixels[off + 3] = 255;
                    }
                }
            }
            
            ctx.putImageData(id, 0, 0);
        }
        
        function drawText(textData){
            if(textData.hid)return;
            /**
                f:"#aaaaaa",
                b:"#666666",
                shc:"#000000",
                x:"center",
                y:"center",
                fs:20,
                ow:2,
                shs:0,
                t:"Text...",
                alg:"center",
                bo:false,
            */
            const fontBuilder = new (class{
                _font = "Comic Sans MS";
                get font(){return this._font}
                set font(value){
                    this._font = value || "Comic Sans MS";
                    this.build();
                }

                _italic = "";
                get italic(){return this._italic}
                set italic(value){
                    this._italic = value ? "italic" : "";
                    this.build();
                }

                _bold = "";
                get bold(){return this._bold}
                set bold(value){
                    this._bold = value ? "bold" : "";
                    this.build();
                }

                _fontSize = "";
                get fontSize(){return this._fontSize}
                set fontSize(value){
                    this._fontSize = value ? value + "pt" : "";
                    this.build();
                }

                build(){
                    ctx.font = [this.italic, this.bold, this._fontSize, this.font].join(" ");
                }
            })()

            fontBuilder.bold = textData.bo;
            fontBuilder.italic = textData.it;
            fontBuilder.fontSize = fontBuilder.dfontSize = textData.fs;
            fontBuilder.font = fontBuilder.dfont = textData.fo;

            //ctx.font = (textData.bo? "bold " : "") + (textData.it? "italic " : "") + (textData.fs* tscale) + "pt " + (textData.fo || "Comic Sans MS");
            ctx.strokeStyle = textData.b;
            ctx.textAlign = "left";//textData.alg;
            var oldbsl = ctx.textBaseline;
            ctx.textBaseline = textData.basl;
            ctx.lineWidth=textData.ow * tscale;
            ctx.fillStyle=textData.f;

            drawOut = textData.ow > 0;
            
            ctx.shadowColor = textData.shc;
            ctx.shadowBlur = textData.shs;//m

            let mtchd = "";
            for(let i =20; i < 1000; i++){
                if(textData.t.indexOf(String.fromCharCode(i)) == -1){
                    mtchd = String.fromCharCode(i);
                    break;
                }
            }

            let stempstr = textData.t;

            while(stempstr != (stempstr = parseStr(stempstr))){
            }
            function nrm(s) {
                return s.split("").map(e => {
                if (/[\^\|\[\]\-\\\/\*\+\.\?\:\{\}\$\#\&]/.test(e)) {
                    return `\\${e}`;
                } return e
                }).join("");
            }
            for(let i in varsC.varsC){
                stempstr = stempstr.replace(new RegExp(nrm(`@${i}`),"gm"), varsC.varsC[i]);
            }

            let tempstr = stempstr.replace(/(?<!\\)<\/?([^=>]+)(=[^<]+)?>/gm, mtchd).replace(/(?<!\\)\\/gm, "");
            let textpcs = tempstr.split("\n");
            let allKys = stempstr.match(/(?<!\\)<\/?([^=>]+)(=[^<]+)?>/gm) || [];
            let offsetTop = 0;
            let offsetlr = 0;

            
            for(let i = 0; i < textpcs.length; i++){
                let f = (measure = false)=>{
                    let allKysu = allKys;
                    if(measure){
                        allKysu = [...allKys];
                    }
                    let offs = (off-10)* (tscale);
                    let posX = textData.x == "center" ? tiledPos(tiles[0].length/2, 0)[0] : textData.x.endsWith("tl") ? tiledPos(parseFloat(textData.x)-0.5, 0)[0] : ((parseFloat(textData.x))* tscale+offs),//((parseFloat(textData.x)-(off!=10?off* tscale:0))* tscale),
                    posY = textData.y == "center" ? tiledPos(0, tiles.length/2)[1] : textData.y.endsWith("tl") ? tiledPos(0, parseFloat(textData.y)-0.5)[1] : ((parseFloat(textData.y))* tscale+offs);//((parseFloat(textData.y)-(off!=10?off* tscale:0))* tscale);
                    
                    let tempdta = measure ? {} : {    
                        font: ctx.font,
                        strokeStyle: ctx.strokeStyle,
                        textAlign: ctx.textAlign,//textData.alg;
                        lineWidth: ctx.lineWidth,
                        fillStyle: ctx.fillStyle,
                        
                        shadowColor: ctx.shadowColor,
                        shadowBlur: ctx.shadowBlur,
                    };
                    let ooffsetTop = offsetTop;
                    let ooffsetlr = offsetlr;
                        
                    let fullText = measure ? 0 : f(true)//ctx.measureText(textpcs[i].replace(new RegExp(mtchd, "gm"), ""));
                    
                    if(!measure){
                        Object.assign(ctx, tempdta);
                        offsetTop = ooffsetTop;
                        offsetlr = ooffsetlr;
                    }

                    let temps = textpcs[i].split(mtchd);
                    let offsetLeft = fullText/2;
                    if(textData.alg == "center"){
                        offsetLeft = fullText/2;
                    }else
                    if(textData.alg == "left"){
                        offsetLeft = fullText;
                        //ctx.textAlign = "right";
                        //temps = temps.reverse();
                        //allKysu = allKysu.reverse();
                    }else
                    if(textData.alg == "right"){
                        offsetLeft = fullText;
                    }

                    allKysu.unshift(null);
                    
                    /*if(textData.alg == "left"){
                        let nr = [];
                        for(let j = 0; j < temps.length; j++){
                            nr.push(allKysu?.shift());
                        }
                        allKysu = nr.reverse();
                    }*/
                    //fullText = 0;
                    for(let j = 0; j < temps.length; j++){
                        let argData = getTextArgs(allKysu?.shift());
                        if(argData){
                            switch(argData.key){
                                /*case "var":{
                                    argData.value = getTextArgVar(argData.value);
                                    if(varsC.vars[argData.value[0]]){
                                        temps.splice(j,0, ...("<blank>"+varsC.vars[argData.value[0]]+"<blank>").format(...argData.value.slice(1)).replace(/(?<!\\)<\/?([^=>]+)(=[^<]+)?>/gm, mtchd).replace(/(?<!\\)\\/gm, "").split(mtchd).slice(1,-1))
                                        allKysu.unshift(...(("<blank>"+varsC.vars[argData.value[0]]+"<blank>").format(...argData.value.slice(1)).match(/(?<!\\)<\/?([^=>]+)(=[^<]+)?>/gm)|| [null]));
                                        j = j-1;

                                        continue;
                                    }
                                    break;
                                }*/
                                case "c":
                                case "clr":
                                case "color":{
                                    if(argData.value != "close"){
                                        ctx.fillStyle=argData.value;
                                    }else{
                                        ctx.fillStyle=textData.f;
                                    }
                                    break;
                                }
                                case "oc":
                                case "oclr":
                                case "outlinecolor":{
                                    if(argData.value != "close"){
                                        ctx.strokeStyle=argData.value;
                                    }else{
                                        ctx.strokeStyle=textData.b;
                                    }
                                    break;
                                }
                                case "sc":
                                case "sclr":
                                case "shadowcolor":{
                                    if(argData.value != "close"){
                                        ctx.shadowColor=argData.value;
                                    }else{
                                        ctx.shadowColor=textData.shc;
                                    }
                                    break;
                                }
                                case "ss":
                                case "ssize":
                                case "shadowsize":{
                                    if(argData.value != "close"){
                                        ctx.shadowBlur=argData.value* tscale;
                                    }else{
                                        ctx.shadowBlur=textData.shs;
                                    }
                                    break;
                                }
                                case "os":
                                case "osize":
                                case "outlinesize":{
                                    if(argData.value != "close"){
                                        ctx.lineWidth = argData.value* tscale;
                                        drawOut = argData.value > 0;
                                    }else{
                                        ctx.lineWidth = textData.ow;
                                        drawOut = textData.ow > 0;
                                    }
                                    break;
                                }
                                case "x":{
                                    if(argData.value != "close"){
                                        offsetlr += (parseFloat(argData.value.replace("--", "+")) || 0)* tscale;
                                    }
                                    break;
                                }
                                case "y":{
                                    if(argData.value != "close"){
                                        offsetTop += (parseFloat(argData.value.replace("--", "+")) || 0)* tscale;
                                    }else{
                                        offsetTop = 0;
                                    }
                                    break;
                                }
                                case "b":
                                case "bold":{
                                    if(argData.value != "close"){
                                        fontBuilder.bold = true;
                                    }else{
                                        fontBuilder.bold = false;
                                    }
                                    break;
                                }
                                case "i":
                                case "italic":{
                                    if(argData.value != "close"){
                                        fontBuilder.italic = true;
                                    }else{
                                        fontBuilder.italic = false;
                                    }
                                    break;
                                }
                                case "fs":
                                case "fontsize":{
                                    if(argData.value == "close"){
                                        fontBuilder.fontSize = fontBuilder.dfontSize;
                                    }else{
                                        fontBuilder.fontSize = parseFloat(argData.value) || fontBuilder.dfontSize;
                                    }
                                    break;
                                }
                                case "f":
                                case "font":{
                                    if(argData.value == "close"){
                                        fontBuilder.font = fontBuilder.dfont;
                                    }else{
                                        fontBuilder.font = argData.value;
                                        cssm.add(new cssm.el(argData.value, cssm.consts.font.format(argData.value.replace(' ', '+'))))
                                    }
                                    break;
                                }
                            }
                        }

                        if(!measure){
                            if(drawOut) ctx.strokeText(temps[j], posX - offsetLeft + offsetlr + (textData.alg == "left" ? fullText : 0), posY + (i*textData.lh*tscale) + offsetTop);
                            let temp = [ctx.shadowColor, ctx.shadowBlur];
                            if(drawOut){
                                ctx.shadowColor = "";
                                ctx.shadowBlur =0;
                            }
                            ctx.fillText(temps[j], posX - offsetLeft + offsetlr + (textData.alg == "left" ? fullText : 0), posY + (i*textData.lh*tscale) + offsetTop);
                            ctx.shadowColor = temp[0], ctx.shadowBlur = temp[1];
                        }
                        let textd = ctx.measureText(temps[j])
                        
                        if(textData.alg == "center"){
                            offsetLeft -= textd.width;
                        }else
                        if(textData.alg == "left"){
                            offsetLeft -= textd.width;
                        }else
                        if(textData.alg == "right"){
                            offsetLeft -= textd.width;
                        }
                        if(measure) fullText += textd.width;
                        //offsetLeft -= textd.width;
                    }
                    return fullText;
                }
                f();
            }
            ctx.shadowBlur = 0;
            ctx.textBaseline = oldbsl;
        }

        function getTextArgs(text){
            if(text){
                let textt = text.replace(/(^\<\/?)|(\>$)/gm, "")?.split("=");    
                if(text.startsWith("</")){
                    return {value:"close", key:textt[0]}
                }else{
                    return {value:textt.slice(1).join("="), key:textt[0]}
                }
            }
            return null;
        }

        function parseStr(str){
            let res = ``;
            let isvar = false;
            let level = 0;
            let keyfnd = false;
            let key = ``;
            let args = [];
            let lastsl = false;
            for(let i = 0; i < str.length; i++){
                let s = str[i];
                if(!lastsl && s == `\\`){
                    lastsl = true;
                    i++;
                    if(!keyfnd && isvar){
                        key += str[i];
                    }else
                    if(isvar){
                        args[args.length-1] += str[i];
                    }else{
                        res += str[i];
                    }
                    continue;
                }
                lastsl = false;

                if((isvar && s == `<`) || (!isvar && str.slice(i+1, i + 5) == "var=")){
                    if(!isvar){
                        i+=4;
                        isvar = true;
                        key = ``;
                        args = [];
                        continue;
                    }
                    if(keyfnd){
                        level++
                    }
                    
                }else
                if((keyfnd && isvar && s == `>`)){
                    level--;
                    if(level == 0){
                        isvar = false;
                        keyfnd = false;
                        if(varsC.vars[key]){
                            let addd = varsC.vars[key].format(...args);
                            res += addd;
                            //i += addd.length;
                        }
                        continue;
                    }
                }
                if(!keyfnd && isvar){
                    if(s==`;`){
                        level++
                        keyfnd = true;
                        args.push(``);
                    }
                    else{
                        key += s;
                    }
                }else
                if(isvar){
                    if(s == `;` && level == 1){
                        args.push(``);
                        continue;
                    }
                    args[args.length-1] += s;
                }else{
                    res += s;
                }

            }

            return res;
        }

        function getTextArgVar(v){
            let r = v.split(/(?<!\\);/gm) || [];
            r.map(v=>v.replace(/\\(?=;)/gm, ""));
            return r;
        }

        function recolor(input, toppart = false){
            let p = toppart? document.querySelector(`div[colorkey="${input.childNodes[0].data.trim()}"]`): input.parentNode;
            let k = p.getAttribute("colorKey");
            let c = p.querySelectorAll("input");
            let idx = ["h", "s", "l"];
            for(let v of Object.values(c)){
                if(v.getAttribute("colorType") == 0){
                    types[k].f[idx.indexOf(v.getAttribute("color"))] = v.value;
                }
                else{
                    types[k].b[idx.indexOf(v.getAttribute("color"))] = v.value;
                }
            }

            p.querySelectorAll(`[color="preview"]`).forEach(e=>{
                e.style.backgroundColor = getColor(types[k].f);//`hsl(${types[k].f[0]},${types[k].f[1]}%,${types[k].f[2]}%)`;
                e.style.borderColor = getColor(types[k].b);//`hsl(${types[k].b[0]},${types[k].b[1]}%,${types[k].b[2]}%)`;
            })

            document.querySelector(`input[colorkey="${k}"][mod-c]`).value=HSLToHex(types[k].f[0]%360,inRange(0,100,types[k].f[1]),inRange(0,100,types[k].f[2]));
            document.querySelector(`input[colorkey="${k}"][mod-ou]`).value=HSLToHex(types[k].b[0]%360,inRange(0,100,types[k].b[1]),inRange(0,100,types[k].b[2]));
            
            redrawTiles();
        }

        function getColor(arr){
            return `hsl(${arr[0]},${arr[1]}%,${arr[2]}%)`
        }

        function addColor(parentNode, restore = -1, clone = -1){
            let newEl;
            if(restore  == -1){
                types.push(newEl={//1
                    f:[0,50,50],
                    b:[0,50,45],
                })
                if(clone != -1){
                    newEl.f = [...types[clone].f]
                    newEl.b = [...types[clone].b]
                };
            }else{
                newEl = types[restore];
            }

            let id = restore!=-1?restore:types.length-1;
            let span = document.createElement("span");
            span.innerHTML = `${id}
            <input type="color" colorkey="${id}" mod-ou>
            <input type="color" colorkey="${id}" mod-c>
            <button class="pasive" onclick="addColor(this.parentNode.parentNode, -1, ${id})" colorkey="${id}">Clone</button>`;
            span.querySelector("input[mod-c]").setAttribute("oninput", `let v = hexToHSL(this.value);
            this.parentNode.parentNode.querySelector(\"div[colorkey=\'${id}\'] > *[colorType=\'0\'][color=\'h\']\").value = v[0];
            this.parentNode.parentNode.querySelector(\"div[colorkey=\'${id}\'] > *[colorType=\'0\'][color=\'s\']\").value = v[1];
            this.parentNode.parentNode.querySelector(\"div[colorkey=\'${id}\'] > *[colorType=\'0\'][color=\'l\']\").value = v[2];
            recolor(this.parentNode, true);`)
            span.querySelector("input[mod-ou]").setAttribute("oninput", `let v = hexToHSL(this.value);
            this.parentNode.parentNode.querySelector(\"div[colorkey=\'${id}\'] > *[colorType=\'1\'][color=\'h\']\").value = v[0];
            this.parentNode.parentNode.querySelector(\"div[colorkey=\'${id}\'] > *[colorType=\'1\'][color=\'s\']\").value = v[1];
            this.parentNode.parentNode.querySelector(\"div[colorkey=\'${id}\'] > *[colorType=\'1\'][color=\'l\']\").value = v[2];
            recolor(this.parentNode, true);`)
            parentNode.appendChild(span);

            let div = document.createElement("div");
            div.className = "tool-holder";
            div.setAttribute("colorKey", id);
            div.innerHTML = 
            `<input colorType="0" color="h" placeholder="h" type="number" oninput="recolor(this)" value="${newEl.f[0]}">
            <input colorType="0" color="s" placeholder="s" type="number" oninput="recolor(this)" value="${newEl.f[1]}">
            <input colorType="0" color="l" placeholder="l" type="number" oninput="recolor(this)" value="${newEl.f[2]}">
            <button color="preview" onclick="toolInfo = {a:'set', v:${id}}"></button>
            
            <input colorType="1" color="h" placeholder="h" type="number" oninput="recolor(this)" value="${newEl.b[0]}">
            <input colorType="1" color="s" placeholder="s" type="number" oninput="recolor(this)" value="${newEl.b[1]}">
            <input colorType="1" color="l" placeholder="l" type="number" oninput="recolor(this)" value="${newEl.b[2]}">
            <button color="preview" onclick="toolInfo = {a:'set', v:${id}}"></button>`
            parentNode.appendChild(div);
            recolor(div.childNodes[0]);
        }

        function addText(parentNode, restore = -1, clone = -1){
            let newEl;
            if(restore  == -1){
                texts[currentTi++] = newEl = {
                    hid:false,
                    f:"#aaaaaa",
                    b:"#666666",
                    shc:"#000000",
                    x:"center",
                    y:"center",
                    fs:20,
                    ow:2,
                    shs:0,
                    lh:20,
                    t:"Text...",
                    alg:"center",
                    basl:"alphabetic",
                    bo:false,
                    it:false,
                    fo:"",
                }
                if(clone != -1)Object.assign(newEl, texts[clone]);
            }else{
                newEl = texts[restore];
            }

            if(newEl.fo){
                cssm.add(new cssm.el(newEl.fo,cssm.consts.font.format(newEl.fo.replace(' ', '+')))); 
            }

            let id = restore!=-1?restore:currentTi-1;
            let div = document.createElement("div");
            div.setAttribute("textKey", id);
            div.innerHTML = `
                <div class="topbar">
                    <button class="close" onclick="delete texts[${id}]; delete moving['t'+${id}]; this.parentNode.parentNode.remove();redrawTiles()">X</button>
                    <button class="pasive" onclick="if((this.innerHTML=this.innerHTML=='Move'?'Stop':'Move')=='Stop'){moving['t'+${id}] = 'texts'}else{delete moving['t'+${id}];}">Move</button>
                    <button class="pasive" onclick="addText(this.parentNode.parentNode.parentNode, -1, ${id})">Clone</button>
                    <button class="pasive" onclick="this.innerHTML = ['Hide', 'Show'][+toggleClass(this.parentNode.parentNode, 'hidden')]">Hide</button>
                    <button class="cbdrw ${newEl.hid? "" : "isdrawing"}" onclick="texts[${id}].hid = !toggleClass(this, 'isdrawing');redrawTiles()">Draw</button>
                    </div>
                <div vv="font">font: <input onchange="cssm.add(new cssm.el(this.value,cssm.consts.font.format(this.value.replace(' ', '+'))));cssm.remove(this.ovalue);this.ovalue = this.value;" value="${newEl.fo}" oninput="texts[${id}].fo=this.value;redrawTiles()" title="Font. Default: Comic Sans MS"></div>
                <div vv="text">text: <textarea value="${newEl.t}" oninput="texts[${id}].t=this.value;redrawTiles()"
                    title="
Displayed text; args are used as <key=value> = set; </key> = revert to default
c,clr,color - text color
oc,oclr,outlinecolor - text outline color
os,osize,outlinesize - text outline size
sc,sclr,shadowcolor - text shadow color
ss,ssize,shadowsize - text shadow size
x - offsetX
y - offsetY
b,bold - bold
i,italic - italic
                    ">${newEl.t}</textarea></div>
                <div vv="color">color: ${colorHelpTip}<input value="${newEl.f.slice(0,7)}" oninput="texts[${id}].f=this.value+texts[${id}].f.slice(7);redrawTiles()" type="color"></div>
                <div vv="alpha">alpha: <input type="range" min="0" max="255" step="1" value="${parseInt(newEl.f.slice(7) || "ff", 16)}" oninput="texts[${id}].f=texts[${id}].f.slice(0,7)+parseInt(this.value).toString(16);if(texts[${id}].f.length == 8){texts[${id}].f=texts[${id}].f.insertAt('0', 7)};redrawTiles()" type="color"></div>
                <div vv="outline">outline: ${colorHelpTip}<input value="${newEl.b}" oninput="texts[${id}].b=this.value+texts[${id}].b.slice(7);redrawTiles()" type="color"></div>
                <div vv="alpha">alpha: <input type="range" min="0" max="255" step="1" value="${parseInt(newEl.b.slice(7) || "ff", 16)}" oninput="texts[${id}].b=texts[${id}].b.slice(0,7)+parseInt(this.value).toString(16);if(texts[${id}].b.length == 8){texts[${id}].b=texts[${id}].b.insertAt('0', 7)};redrawTiles()" type="color"></div>
                <div vv="shadow color">shadow color: ${colorHelpTip}<input value="${newEl.shc}" oninput="texts[${id}].shc=this.value;redrawTiles()" type="color"></div>
                <div vv="x">x: <input value="${newEl.x}" oninput="texts[${id}].x=this.value;redrawTiles()" title="values: number e.g. 5,565,123.5; center; tiled position e.g. 2tl"></div>
                <div vv="y">y: <input value="${newEl.y}" oninput="texts[${id}].y=this.value;redrawTiles()" title="values: number e.g. 5,565,123.5; center; tiled position e.g. 2tl"></div>
                <div vv="size">size: <input value="${newEl.fs}" oninput="texts[${id}].fs=this.value;redrawTiles()" type="number" title="font size"></div>
                <div vv="outline size">outline size: <input value="${newEl.ow}" oninput="texts[${id}].ow=this.value;redrawTiles()" type="number"></div>
                <div vv="shadow size">shadow size: <input value="${newEl.shs}" oninput="texts[${id}].shs=this.value;redrawTiles()" type="number"></div>
                <div vv="line height">line height: <input value="${newEl.lh}" oninput="texts[${id}].lh=this.value;redrawTiles()" type="number" title="splited line height"></div>
                <div vv="bold">bold: <input ${newEl.bo ? "checked" : ""} onchange="texts[${id}].bo=this.checked;redrawTiles()" type="checkbox"></div>
                <div vv="bold">italic: <input ${newEl.it ? "checked" : ""} onchange="texts[${id}].it=this.checked;redrawTiles()" type="checkbox"></div>
                <div vv="align" title="text align">align: 
                    <select oninput="texts[${id}].alg=this.value;redrawTiles()">
                        <option value="center"${newEl.alg == "center" ? ` selected` : ""}>Center</option>
                        <option value="left"${newEl.alg == "left" ? ` selected` : ""}>Left</option>
                        <option value="right"${newEl.alg == "right" ? ` selected` : ""}>Right</option>
                    </select>
                </div>
                <div vv="basl" title="text baseline">basde line: 
                    <select oninput="texts[${id}].basl=this.value;redrawTiles()">
                        <option value="alphabetic"${newEl.basl == "alphabetic" ? ` selected` : ""}>Alphabetic</option>
                        <option value="top"${newEl.basl == "top" ? ` selected` : ""}>Top</option>
                        <option value="hanging"${newEl.basl == "hanging" ? ` selected` : ""}>Hanging</option>
                        <option value="middle"${newEl.basl == "middle" ? ` selected` : ""}>Middle</option>
                        <option value="ideographic"${newEl.basl == "ideographic" ? ` selected` : ""}>Ideographic</option>
                        <option value="bottom"${newEl.basl == "bottom" ? ` selected` : ""}>Bottom</option>
                    </select>
                </div>
            `;
            div.querySelector("[vv='text']").addEventListener("contextmenu", (e)=>{
                e.preventDefault();

                let selection = [e.target.selectionStart, e.target.selectionEnd];
                
                ContextMenu.create(e,
                    ContextMenu.DEFAULT_TEXT()
                );
            });
            parentNode.appendChild(div);
            redrawTiles();
        }

        function addVar(parentNode, restore = null, type = "t"){
            let newEl;
            if(restore == null){
                newEl = varsC.add({
                    hid:false,
                    k:"",
                    v:"",
                    t:type||"t"
                })
            }else{
                if(!restore[0].t)restore[0].t = "t";
                newEl = varsC.add(restore[0], restore[1]);
            }

            let div = document.createElement("div");
            div.setAttribute("varKey", newEl[1]);
            let newihtml = `
                <div class="topbar">
                    <button class="close" onclick="varsC.remove(${newEl[1]}, '${newEl[0].t}'); this.parentNode.parentNode.remove();redrawTiles()">X</button>
                    <button class="cbdrw ${newEl[0].hid? "" : "isdrawing"}" onclick="varsC.edith(${newEl[1]}, !toggleClass(this, 'isdrawing'), '${newEl[0].t}');redrawTiles()">Use</button>
                </div>
                <div vv="key">key: <input value="${newEl[0].k}" oninput="varsC.editk(${newEl[1]}, this.value, '${newEl[0].t}');redrawTiles()"></div>`;
            if(newEl[0].t == "t")newihtml+=`<div vv="value">value: <input value="${newEl[0].v}" oninput="varsC.editv(${newEl[1]}, this.value, '${newEl[0].t}');redrawTiles()" title="<var=key;argument accepted as {number of the argument} e.g. {0}>"></div>`;
            if(newEl[0].t == "c")newihtml+=`<div vv="value">value: ${colorHelpTip}<input value="${newEl[0].v}" oninput="varsC.editv(${newEl[1]}, this.value, '${newEl[0].t}');redrawTiles()" type="color" title="use as @key"></div>`;
                
            div.innerHTML = newihtml;

            if(newEl[0].t == "t"){
                div.querySelector("[vv='value']").addEventListener("contextmenu", (e)=>{
                    e.preventDefault();

                    let selection = [e.target.selectionStart, e.target.selectionEnd];
                    
                    ContextMenu.create(e,
                        ContextMenu.DEFAULT_TEXT()
                    );
                });
            }

            parentNode.appendChild(div);
            redrawTiles();
        }

        function addShape(parentNode, restore = -1, clone = -1, type = "ci"){
            let newEl;
            if(restore  == -1){
                    shapes[currentSi++] = newEl = type == "ci" ? {
                    texto:1,
                    shape: type,
                    x: "center",
                    y: "center",
                    ra: "23",
                    ou: "5",
                    f: "#aa00ff",
                    b: "#222222",
                    hid: false,
                }: type == "re"? {
                    texto:1,
                    shape: type,
                    x: "center",
                    y: "center",
                    wi: "46",
                    he: "46",
                    ou: "4",
                    f: "#aa00ff",
                    b: "#222222",
                    out:"round",
                    ang: 0,
                    hid: false,
                }: type == "im"? {
                    texto:1,
                    shape: type,
                    x: "center",
                    y: "center",
                    wi: "100%",
                    he: "100%",
                    lin: "",
                    img: null,
                    alp: 1,
                    ang: 0,
                    hid: false,
                    flip:false,
                    flop:false,
                }: type == "dr"? {
                    texto:1,
                    shape: type,
                    x: "center",
                    y: "center",
                    wi: "100%",
                    he: "100%",
                    lin: "",
                    img: null,
                    alp: 1,
                    ang: 0,
                    hid: false,
                    flip:false,
                    flop:false,
                }: type == "iim"? {
                    texto:1,
                    shape: type,
                    x: "center",
                    y: "center",
                    wi: "100%",
                    he: "100%",
                    lin: localReources.images[0],
                    alp: 1,
                    ang: 0,
                    hid: false,
                    flip:false,
                    flop:false,
                }:type == "larc" ? {
                    texto:1,
                    shape: type,
                    x: "center",
                    y: "center",
                    ra: "23",
                    ou: "5",
                    f: "#aa00ff",
                    hid: false,
                }:
                type == "lrect" ? {
                    texto:1,
                    shape: type,
                    x: "center",
                    y: "center",
                    wi: "46",
                    he: "46",
                    ou: "5",
                    f: "#aa00ff",
                    hid: false,
                }:
                {}
                if(clone != -1)Object.assign(newEl, shapes[clone]);
            }else{
                newEl = shapes[restore];
            }

            if(newEl.lin && type != "iim"){
                imagem.getImg(newEl.lin, (link, image)=>{newEl.lin=link;newEl.img=image;redrawTiles()})
            }

            let id = restore!=-1?restore:currentSi-1;
            let div = document.createElement("div");
            div.setAttribute("shapekey", id);
            

            let newihtml = 
            `
            <div class="topbar">
                <button class="close" onclick="delete shapes[${id}]; delete moving['s'+${id}]; this.parentNode.parentNode.remove();redrawTiles()">X</button>
                <button class="pasive" onclick="if((this.innerHTML=this.innerHTML=='Move'?'Stop':'Move')=='Stop'){moving['s'+${id}] = 'shapes'}else{delete moving['s'+${id}];}">Move</button>
                <button class="pasive" onclick="addShape(this.parentNode.parentNode.parentNode, -1, ${id}, shapes[${id}].shape)">Clone</button>
                <button class="pasive" onclick="this.innerHTML = ['Hide', 'Show'][+toggleClass(this.parentNode.parentNode, 'hidden')]">Hide</button>
                <button class="cbdrw ${newEl.hid? "" : "isdrawing"}" onclick="shapes[${id}].hid = !toggleClass(this, 'isdrawing');redrawTiles()">Draw</button>
            </div>
            <div vv="overText">over text: <input ${newEl.texto == 1?"checked":""} onchange="shapes[${id}].texto=this.checked?1:0;redrawTiles()" type="checkbox"></div>`

            if(type != "im" && type != "dr" && type != "iim")newihtml += `<div vv="color">color: ${colorHelpTip}<input value="${newEl.f.slice(0,7)}" oninput="shapes[${id}].f=this.value+shapes[${id}].f.slice(7);redrawTiles()" type="color"></div>
            <div vv="alpha">alpha: <input type="range" min="0" max="255" step="1" value="${parseInt(newEl.f.slice(7) || "ff", 16)}" oninput="shapes[${id}].f=shapes[${id}].f.slice(0,7)+parseInt(this.value).toString(16);if(shapes[${id}].f.length == 8){shapes[${id}].f=shapes[${id}].f.insertAt('0', 7)};redrawTiles()"></div>`
            if(type != "im" && type != "dr" && type != "iim" && type != "larc" && type != "lrect")newihtml +=`<div vv="outline">outline: ${colorHelpTip}<input value="${newEl.b}" oninput="shapes[${id}].b=this.value+shapes[${id}].b.slice(7);redrawTiles()" type="color"></div>
            <div vv="alpha">alpha: <input type="range" min="0" max="255" step="1" value="${parseInt(newEl.b.slice(7) || "ff", 16)}" oninput="shapes[${id}].b=shapes[${id}].b.slice(0,7)+parseInt(this.value).toString(16);if(shapes[${id}].b.length == 8){shapes[${id}].b=shapes[${id}].b.insertAt('0', 7)};redrawTiles()"></div>`
            
            if(type == "im")newihtml += `<div vv="lin">img file: <input value="${newEl.lin}" oninput="imagem.getImg(this, (link, image)=>{shapes[${id}].lin=link;shapes[${id}].img=image;redrawTiles()})" type="file"></div>`
            if(type == "dr")newihtml += `<div vv="lin">img file: <button value="${newEl.lin}" onclick="Paint.create({img:shapes[${id}].img}).onFinish = (link, img)=>{shapes[${id}].lin=link;shapes[${id}].img=img;redrawTiles()}" type="file">Edit</button></div>`
            if(type == "im" || type == "dr" || type == "iim")newihtml += `<div vv="alpha">alpha: <input type="range" min="0" max="1" step="0.01" value="${newEl.alp}" oninput="shapes[${id}].alp=this.value;redrawTiles()"></div>`
            if(type == "iim"){
                newihtml += `<div vv="lin" title="Image name">image name: 
                <select oninput="shapes[${id}].lin=this.value;redrawTiles()">`;
                for(let i in localReources.images){
                    let img = localReources.images[i];
                    let imgName = img.replace(/[\_\-]+/gm, " ");
                    imgName = imgName[0].toUpperCase() + imgName.slice(1);
                    newihtml += `<option value="${img}"${newEl.lin == img ? ` selected` : ""}>${imgName}</option>`;
                }
                newihtml +=`</select></div>`
            }

            newihtml+=`<div vv="x">x: <input value="${newEl.x}" oninput="shapes[${id}].x=this.value;redrawTiles()" title="values: number e.g. 5,565,123.5; center; tiled position e.g. 2tl"></div>
            <div vv="y">y: <input value="${newEl.y}" oninput="shapes[${id}].y=this.value;redrawTiles()" title="values: number e.g. 5,565,123.5; center; tiled position e.g. 2tl"></div>
            
            
            `
            if(type == "ci" || type == "larc")newihtml += `<div vv="radius">radius: <input value="${newEl.ra}" oninput="shapes[${id}].ra=this.value;redrawTiles()" type="number" title="radius"></div>`
            else
            if(type == "re" || type == "im" || type == "dr" || type == "iim" || type == "lrect")newihtml += 
            `<div vv="width">width: <input value="${newEl.wi}" oninput="shapes[${id}].wi=this.value;redrawTiles()" title="width"></div>
            <div vv="height">height: <input value="${newEl.he}" oninput="shapes[${id}].he=this.value;redrawTiles()" title="height"></div>`
        
            if(type != "im" && type != "dr" && type != "iim")newihtml += `<div vv="outline size">outline size: <input value="${newEl.ou}" oninput="shapes[${id}].ou=this.value;redrawTiles()" type="number"></div>`
            if(type == "re")newihtml += `<div vv="align" title="outline cap">outline edges: 
                <select oninput="shapes[${id}].out=this.value;redrawTiles()">
                    <option value="round"${newEl.out == "round" ? ` selected` : ""}>Round</option>
                    <option value="miter"${newEl.out == "miter" ? ` selected` : ""}>Square</option>
                </select>
                </div>`
            if(type == "im" || type == "dr" || type == "re" || type == "iim")newihtml += `<div vv="angle">angle: <input value="${newEl.ang}" oninput="shapes[${id}].ang = this.value;redrawTiles()" type="number" min="-360" max="360"></div>`
            if(type == "im" || type == "dr" || type == "iim")newihtml += `<div vv="angle">flip | flop: <input ${newEl.flop == 1?"checked":""} onchange="shapes[${id}].flop=this.checked?true:false;redrawTiles()" type="checkbox" style="width:30%"><input style="width:30%" ${newEl.flip == 1?"checked":""} onchange="shapes[${id}].flip=this.checked?true:false;redrawTiles()" type="checkbox"></div>`
                        
            newihtml += ``
            div.innerHTML = newihtml; 

            parentNode.appendChild(div);
        }

        const mouse = {
            down:false,
        }
        canvas.addEventListener("mousedown", ()=>{mouse.down = true});
        canvas.addEventListener("mouseup", ()=>{mouse.down = false});
        canvas.addEventListener("click", (e)=>{
            setTileColor("click", e);
            
        })

        canvas.addEventListener("mousemove", (e)=>{
            setTileColor("mousemove", e);
        })

        function setTileColor(act, e){
            if(Object.keys(moving).length == 0){
                let x = Math.floor((e.x - off - ou*3) / (tileW+ ou*2) );
                let y = Math.floor((e.y - off - ou*3) / (tileH+ ou*2) );
                if(x < 0 || y < 0 || y >= tiles.length || x >= tiles[0].length)return;
                if(toolInfo.a == "set"){
                    if(((act == "mousemove" && mouse.down) || act == "click") && tiles[y][x] != toolInfo.v){
                        saves.add(new saves.Field("tile", {x:x,y:y, ov:tiles[y][x], nv:toolInfo.v}))
                        tiles[y][x] = toolInfo.v;
                        redrawTiles();
                    }
                }
            }else
            if(mouse.down){
                if(e.movementX != 0 || e.movementY != 0){
                    for(ii in moving){
                        let htmlTarget = moving[ii] == "shapes" ? "shapekey" : "textkey" 
                        let o = moving[ii] == "shapes" ? shapes : moving[ii] == "texts" ? texts : texts;
                        let i = ii.slice(1);

                        if(o[i].x == "center"){
                            o[i].x = ""+(tiledPos(tiles[0].length/2, 0)[0] + e.movementX);
                        }else
                        if((""+o[i].x).endsWith("tl")){
                            o[i].x = (parseFloat(o[i].x) + (e.movementX/(tileW+ou*2))) + "tl";
                        }else{
                            o[i].x = ""+(parseFloat(o[i].x) + e.movementX);
                        }
    
                        if(o[i].y == "center"){
                            o[i].y = ""+(tiledPos(0, tiles.length/2)[1] + e.movementY);
                        }else
                        if((""+o[i].y).endsWith("tl")){
                            o[i].y = (parseFloat(o[i].y) + (e.movementY/(tileH+ou*2))) + "tl";
                        }else{
                            o[i].y = ""+(parseFloat(o[i].y) + e.movementY);
                        }
                        document.querySelector("*["+htmlTarget+"='"+i+"'] div[vv=x] > input").value = o[i].x;
                        document.querySelector("*["+htmlTarget+"='"+i+"'] div[vv=y] > input").value = o[i].y;
                    }
                    redrawTiles();
                }
            }
        }

        function saveImage(sendFile = true){
            const saveCanvas = document.createElement("canvas");
            let oou = ou, otileW = tileW, otileH = tileH, ooff = off, tCtx;

            tileW = tileW*scale;
            ou = ou*scale;
            tileH = tileH * scale;
            
            if(!outerOutline){

                saveCanvas.width = (tileW + ou*2)*tiles[0].length-ou*2;
                saveCanvas.height = (tileH + ou*2)*tiles.length-ou*2;
                tCtx = saveCanvas.getContext("2d");
                let octx = ctx;
                ctx = tCtx;
                off = -ou*4;
                tscale = scale;
                redrawTiles();
                tscale = 1;
                //tCtx.drawImage(canvas, 10 + ou*4, 10 + ou*4, saveCanvas.width, saveCanvas.height, 0, 0, saveCanvas.width, saveCanvas.height)
                ctx = octx;
            }else{
                saveCanvas.width = (tileW+ ou*2)*tiles[0].length;
                saveCanvas.height = (tileH+ ou*2)*tiles.length;
                tCtx = saveCanvas.getContext("2d");
                let octx = ctx;
                ctx = tCtx;
                off = -ou*3;
                tscale = scale;
                redrawTiles();
                tscale = 1;
                //tCtx.drawImage(canvas, 10 + ou*3, 10 + ou*3, saveCanvas.width, saveCanvas.height, 0, 0, saveCanvas.width, saveCanvas.height)
                ctx = octx;
            }

            ou = oou;
            tileW = otileW;
            tileH = otileH;
            off = ooff;
            
            if(sendFile){
                let link = document.getElementById("link");
                let fname = (filename || ("tiles-" + Date.now())).split(".");
                link.setAttribute('download', fname.slice(0,Math.max(1, fname.length-1)).join(".") + ".png");
                link.setAttribute('href', saveCanvas.toDataURL("image/png").replace("image/png", "image/octet-stream"));
                link.click();
            }
            return tCtx;
        }

        function save(){
            let element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(
                JSON.stringify({
                    tiles:tiles,
                    types:types,
                    texts:texts,
                    shapes:shapes,
                    currentTi:currentTi,
                    currentSi:currentSi,
                    vars:{data: {...varsC.data,...varsC.dataC}, id: varsC.currentVi},
                    meta:{
                        outerOutline:outerOutline,
                        w: tileW,
                        h: tileH,
                        o: ou,
                    }
                })
            ));
            element.setAttribute('download', filename || ("tiles-" + Date.now()));

            element.style.display = 'none';
            document.body.appendChild(element);

            element.click();

            document.body.removeChild(element);
        }

        async function imported(el){
            let file = el.files.item(0);
            if(file){
                text = await file.text();
                //document.getElementById("colors").innerHTML = `<span>colors <button onclick="addColor(this.parentNode.parentNode)">+</button></span>`;
                for(let e = document.getElementById("colors").children, i = e.length-1; i>= 0; i--){
                    if(i >= 1)e[i].remove();
                }
                for(let e = document.getElementById("texts").children, i = e.length-1; i>= 0; i--){
                    if(i >= 1)e[i].remove();
                }
                
                for(let e = document.getElementById("vars").children, i = e.length-1; i>= 0; i--){
                    if(i >= 1)e[i].remove();
                }
                for(let e = document.getElementById("shapes").children, i = e.length-1; i>= 0; i--){
                    if(i >= 2)e[i].remove();
                }

                filename = document.getElementById("fna").value = file.name;
                
                let d = JSON.parse(text);
                

                tiles = d.tiles;
                types = d.types;
                texts = d.texts || {};
                shapes = d.shapes || {};
                currentTi = d.currentTi || 0;
                currentSi = d.currentSi || 0;

                varsC.currentVi = d.vars?.id || 0;
                let va = document.getElementById("vars");
                for(let i in d.vars?.data || {}){
                    addVar(va, [d.vars.data[i], i], d.vars.data[i].t || "t");
                }
                
                varsC.generate();

                if(d.meta){
                    let el = document.getElementById("tiles");

                    document.querySelector("#outl").checked = outerOutline = d.meta.outerOutline || false;
                    el.querySelector("#tw").value = tilescnt[0] = tiles.length || tilescnt[0];
                    el.querySelector("#th").value = tilescnt[1] = tiles[0].length || tilescnt[1];
                    el.querySelector("#tou").value = ou = d.meta.o || ou;
                    el.querySelector("#tsw").value = tileW = d.meta.w || tileW;
                    el.querySelector("#tsh").value = tileH = d.meta.h || tileH;
                }
                


                let c = document.getElementById("colors");
                for(let i = 0; i < types.length; i++){
                    addColor(c, i);
                }
                let t = document.getElementById("texts");
                for(let i in texts){
                    addText(t, i);
                }
                let s = document.getElementById("shapes");
                for(let i in shapes){
                    addShape(s, i, -1, shapes[i].shape);
                }
                redrawTiles();
            }
        }

        const saves = new(class Saves{
            Field = class Field{
                act = "none";
                x = -1;
                y = -1;
                ov = -1;
                nv = -1;
                constructor(act, data = {x:-1, y:-1, ov: -1, nv: -1}){
                    this.act = act;
                    Object.assign(this, data || {});
                }
            }

            fields = [];
            currentId = -1;
            lastDir = -1;

            constructor(){
            }

            add(field){

                if(this.currentId != -1){
                    this.fields.splice(this.lastDir == +1 ? this.currentId+1 : this.currentId);
                    this.currentId = -1;
                    this.lastDir = -1;
                }
                let prevF = this.fields[this.fields.length-1];
                if(prevF && prevF.act == field.act && prevF.x == field.x && prevF.y == field.y && prevF.nv == field.nv)return;
                
                this.fields.push(field);
            }
            
            undo(dir = -1){
                if(this.currentId == -1) this.currentId = this.fields.length;

                if(this.lastDir == (this.lastDir = dir)) this.currentId = Math.max(0,Math.min(this.currentId + dir, this.fields.length-1));

                let last = this.fields[this.currentId == -1 ? this.fields.length-1 : this.currentId];
                if(last){
                    switch(last.act){
                        case "tile":
                            tiles[last.y][last.x] = dir == -1 ? last.ov : last.nv;
                            redrawTiles();
                        default:
                            break;
                    }
                }
            }
        })();

        const imagem = new(class Imagem{
            getImg(file, cb){//e.target.files[0]
                if(typeof file != "string") file = URL.createObjectURL(file.files[0]);
                let image = new Image();
                image.onload = ()=>{
                    cb(this.imageUrl(image), image);
                }
                image.src = file;

                image.onerror = ()=>{
                    cb("", null);
                }
            }

            imageUrl(img){

                let saveCanvas = document.createElement("canvas");
                saveCanvas.width = img.width;
                saveCanvas.height = img.height;
                let tCtx = saveCanvas.getContext("2d");
                tCtx.drawImage(img,0,0);
                return saveCanvas.toDataURL("image/png");
            }
        })()

        const cssm = new(class Cssm{
            element = null;

            el = class dataPref{
                id = -1;
                enabled = true;

                constructor(key, value){
                    this.key = key;
                    this.value = value;
                }
            }

            els = [];
            
            consts = {
                font: `@import url('https://fonts.googleapis.com/css2?family={0}&display=swap');`
            }

            constructor(){
                this.element = document.createElement("style");
                document.head.appendChild(this.element);
            }

            add(data){
                if(this.els.some((e)=>e.key == data.key)) return;
                this.els.push(data);
                data.id = this.els.length-1;
                this.recalc();
            }

            remove(key){
                if(!key)return;

                let i = this.els.findIndex((e)=>e.key == key);
                if(i >= 0){
                    this.els.splice(i,1);
                    this.recalc();
                }
            }

            recalc(){
                if(this.element){
                    let newIHTML = ``;

                    
                    for(let key in this.els){
                        let e = this.els[key];

                        if(e.enabled){
                            newIHTML += e.value + `\n`;
                        }
                    }

                    this.element.innerHTML = newIHTML;
                }
            }
        })();

        class ContextMenu{
            static DEFAULT_TEXT = ()=> [
                {
                    name:"Color",
                    content:[
                        {
                            name:"Text color",
                            final:["<c={V0}>{T}", "</c>"],
                            input:[{type:"color"}],
                            options: Object.values(varsC.dataC).map(e=>"@"+e.k)
                        },
                        {
                            name:"Outline color",
                            final:["<oc={V0}>{T}", "</oc>"],
                            input:[{type:"color"}],
                            options: Object.values(varsC.dataC).map(e=>"@"+e.k)
                        },
                        {
                            name:"Shadow color",
                            final:["<sc={V0}>{T}", "</sc>"],
                            input:[{type:"color"}],
                            options: Object.values(varsC.dataC).map(e=>"@"+e.k)
                        },
                    ]
                },
                {
                    name:"Size",
                    content:[
                        {
                            name:"Outline size",
                            final:["<os={V0}>{T}", "</os>"],
                            input:[{type:"number"}]
                        },
                        {
                            name:"Shadow size",
                            final:["<ss={V0}>{T}", "</ss>"],
                            input:[{type:"number"}]
                        },
                    ]
                },
                {
                    name:"Font decorations",
                    content:[
                        {
                            name:"Bold",
                            final:["<b>{T}", "</b>"],
                            input:[]
                        },
                        {
                            name:"Italic",
                            final:["<i>{T}", "</i>"],
                            input:[]
                        },
                        {
                            name:"UnBold",
                            final:["</b>{T}"],
                            input:[]
                        },
                        {
                            name:"UnItalic",
                            final:["</i>{T}"],
                            input:[]
                        },
                        {
                            name:"Font",
                            final:["<f={V0}>{T}", "</f>"],
                            input:[{type:"text"}]
                        },
                        {
                            name:"Font size",
                            final:["<fs={V0}>{T}", "</fs>"],
                            input:[{type:"number"}]
                        },
                    ]
                },
                {
                    name:"Position",
                    content:[
                        {
                            name:"X",
                            final:["<x={V0}>{T}", "<x=-{V0}>"],
                            input:[{type:"number"}]
                        },
                        {
                            name:"Y",
                            final:["<y={V0}>{T}", "<y=-{V0}>"],
                            input:[{type:"number"}]
                        },
                    ]
                },
                {
                    name:"Variable",
                    content:[
                        {
                            name:"Builtin",
                            final:["<var={V0};{T}>"],
                            options: Object.keys(varsC.varsp)
                        },
                        {
                            name:"Custom",
                            final:["<var={V0};{T}>"],
                            options: [...Object.values(varsC.data).map(e=>e.k),...Object.values(varsC.dataC).map(e=>"@"+e.k)]
                        },
                    ]
                }
            ];
            static bg = null;
            static contextMenu = null;

            static close(){
                if(ContextMenu.contextMenu) ContextMenu.contextMenu.popup.remove();
                ContextMenu.bg.style.display = "none";
            }
            
            static create(event, data){
                ContextMenu.close();
                ContextMenu.bg.style.display = "unset";
                return ContextMenu.contextMenu = new ContextMenu(event, data);
            }

            static init(){
                let bg = ContextMenu.bg = document.createElement("div");
                bg.style.width = bg.style.height = "100%";
                bg.style.position = "absolute";
                bg.style.left = bg.style.top = "0";
                bg.style.display = "none";
                bg.addEventListener("click", ()=>{
                    ContextMenu.close();
                });
                document.body.appendChild(bg);
            }


            constructor(event, data){
                //pageX: 961 pageY: 290 window.innerHeight
                this.data = data;
                
                this.targetInput = event.target;
                this.selection = [event.target.value, event.target.selectionStart, event.target.selectionEnd];

                this.popup = document.createElementP("div", {style:{right: event.pageX}, className:"contextMenu"}, (popup)=>{
                    popup.style.right = (window.innerWidth - event.pageX) + "px";

                    if(event.pageY < window.innerHeight/2){
                        popup.style.top = event.pageY + "px";
                    }else{
                        popup.style.bottom = (window.innerHeight - event.pageY) + "px";
                    }
                });
                this.fillContent(this.data);
                document.body.appendChild(this.popup);
            }

            fillContent(data){
                this.popup.innerHTML = "";
                for(let i in data){
                    let d = data[i];
                    this.popup.appendChild(document.createElementP("button", {className:"contextMenuBtn"}, (btn)=>{
                        btn.innerText = d.name;
                        if(d.content) btn.classList.add("extensive");

                        btn.addEventListener("click", (e)=>{
                            if(d.content){
                                this.fillContent(d.content);
                            }else{
                                this.popup.innerHTML = "";
                                if(d.input){
                                    this.fillInputs(d.input);
                                    this.onFinalizeD = d;
                                    //this.onFinalize = (result)=>{}
                                }
                                if(d.options){
                                    this.fillOptions(d.options);
                                    this.onFinalizeD = d;
                                }
                            }
                        })
                    }));
                }
            }

            fillInputs(data){
                let res = {};
                for(let i in data){
                    let d = data[i];
                    this.popup.appendChild(document.createElementP("input", {className:"contextMenuBtn", type: d.type}, (input)=>{
                        input.innerText = d.name;
                        res[i] = "#0000";
                        input.addEventListener("input", (e)=>{
                            res[i] = input.value;
                            /*if(input.type == "color"){
                                input.type = "";
                                input.type = "color";
                            }*/
                        })
                    }));
                }

                this.popup.appendChild(document.createElementP("button", {className:"contextMenuBtn"}, (btn)=>{
                    btn.innerText = "Submit";

                    btn.addEventListener("click", (e)=>{
                        this.onFinalize(res);
                        ContextMenu.close();
                    })
                }));
            }

            fillOptions(data){
                let res = {};
                for(let i in data){
                    let d = data[i];
                    this.popup.appendChild(document.createElementP("button", {className:"contextMenuBtn"}, (btn)=>{
                    btn.innerText = d;

                    btn.addEventListener("click", (e)=>{
                        this.onFinalize({0:d});
                        ContextMenu.close();
                    })
                }));
                }
            }

            onFinalize(result){
                this.selection;
                let res = this.selection[0].slice(0,this.selection[1]);
                
                for(let i in result){
                    this.onFinalizeD.final[0] = this.onFinalizeD.final[0].replace(`{V${i}}`, result[i])
                }
                let lenDiff1 = res.length;
                res += this.onFinalizeD.final[0].replace("{T}", this.selection[0].slice(this.selection[1],this.selection[2]));
                lenDiff1 = res.length - lenDiff1;

                if(this.selection[1] != this.selection[2] && this.onFinalizeD.final.length > 1){
                    for(let i in result){
                        this.onFinalizeD.final[1] = this.onFinalizeD.final[1].replace(`{V${i}}`, result[i])
                    }
                    res += this.onFinalizeD.final[1];
                }
                res += this.selection[0].slice(this.selection[2],this.selection[0].length);

                let lenDiff2 = res.length - this.targetInput.value.length;
                this.targetInput.value = res;
                if(this.targetInput.oninput) this.targetInput.oninput()
                redrawTiles();

                if(this.selection[1] != this.selection[2]){
                    this.targetInput.select();
                    let index = res.indexOf(this.selection[0].slice(this.selection[1],this.selection[2]), this.selection[1]);
                    this.targetInput.selectionStart = index;
                    this.targetInput.selectionEnd = index - this.selection[1] + this.selection[2];
                }else{
                    this.targetInput.select();
                    this.targetInput.selectionEnd = this.targetInput.selectionStart = this.selection[1] + lenDiff1; 
                }
                /*this.targetInput.selectionStart = this.selection[1];
                this.targetInput.selectionEnd = this.selection[1] == this.selection[2] ? this.selection[1]:
                this.selection[2] + lenDiff2;*/
            }
        }
        ContextMenu.init();

        class Paint{
			static brushes = [
				{
					name:"Erasor",
					begin: null,
					move:function(ctx, x, y, size){
						let ogco = ctx.globalCompositeOperation;
						ctx.globalCompositeOperation = 'destination-out'
						ctx.beginPath();
						ctx.arc(x, y, size, 0, Math.PI*2);
						ctx.fill();
						ctx.closePath();
						ctx.globalCompositeOperation = ogco;
					},
					end:null,
				},
                {
					name:"Spray",
                    init: [
                        {name:"particle size", type:"number", min: 0.01, max: 1, step:0.05, default:0.2},
                        {name:"particles", type:"number", min: 1, max: 100, step:1, default:10},
                    ],
					begin: null,
					move:function(ctx, x, y, size){
                        let innerRadius = parseFloat(this.init[0].value || this.init[0].default);
                        let count = parseInt(this.init[1].value || this.init[1].default);

                        for(let i = 0; i < count; i++){
                            let angle = Math.random()*Math.PI*2;
                            ctx.beginPath();
                            ctx.arc(x + Math.cos(angle) * (size * (1-innerRadius)) * Math.random(), y + Math.sin(angle) * (size * (1-innerRadius)) * Math.random(), innerRadius* size, 0, Math.PI*2);
                            ctx.fill();
                            ctx.closePath();
                        }

					},
					end:null,
				},
                {
					name:"Spray outer",
                    init: [
                        {name:"particle size", type:"number", min: 0.01, max: 1, step:0.05, default:0.2},
                        {name:"particles", type:"number", min: 1, max: 100, step:1, default:10},
                    ],
					begin: null,
					move:function(ctx, x, y, size){
                        let innerRadius = parseFloat(this.init[0].value || this.init[0].default);
                        let count = parseInt(this.init[1].value || this.init[1].default);

                        for(let i = 0; i < count; i++){
                            let angle = Math.random()*Math.PI*2;
                            ctx.beginPath();
                            ctx.arc(x + Math.cos(angle) * (size * (1-innerRadius)), y + Math.sin(angle) * (size * (1-innerRadius)), innerRadius* size, 0, Math.PI*2);
                            ctx.fill();
                            ctx.closePath();
                        }

					},
					end:null,
				},
				{
					name:"Circle",
					begin: null,
					move:function(ctx, x, y, size){
						ctx.beginPath();
						ctx.arc(x, y, size, 0, Math.PI*2);
						ctx.fill();
                        ctx.closePath();
					},
					end:null,
				},
                {
					name:"Comet-like Circle",
					begin: function(ctx, x, y, size){
						ctx.beginPath();
						ctx.arc(x, y, size, 0, Math.PI*2);
						ctx.fill();
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.strokeStyle = ctx.fillStyle;
                        ctx.lineWidth = size*2;
                        ctx.lineCap = "round";
                        this.storage = [x,y];
					},
					move:function(ctx, x, y, size){
						ctx.quadraticCurveTo(x,y, this.storage[0],this.storage[1]);
                        this.storage = [x,y];
						ctx.stroke();
					},
					end:function(ctx, x, y, size){
                        ctx.closePath();
                    },
				},
				{
					name:"Multi Angle",
                    init: [
                        {name:"angle count", type:"number", min: 3, max: 20, step:1, default:3},
                        {name:"shape angle", type:"number", min: -360, max: 360, step:1, default:0}
                    ],
					begin: null,
					move: function(ctx, x, y, size){
                        let angles = parseInt(this.init[0].value || this.init[0].default);

						ctx.beginPath();
						let angle = -parseInt(this.init[1].value || this.init[1].default) / 180 * Math.PI + Math.PI;
						ctx.moveTo(x + Math.sin(angle)*size, y + Math.cos(angle)*size);
						for(let i = 1; i < angles; i++){
							angle += Math.PI*2 / angles;
							ctx.lineTo(x + Math.sin(angle)*size, y + Math.cos(angle)*size);
						}
						ctx.fill();
						ctx.closePath();
					},
					end:null,
				},
				{
					name:"Random Multi Angle",
                    init: [{name:"angle count", type:"number", min: 3, max: 20, step:1, default:3}],
					begin: null,
					move:function(ctx, x, y, size){
                        let angles = parseInt(this.init[0].value || this.init[0].default);

						ctx.beginPath();
						let angle = Math.random() * Math.PI*2;
						ctx.moveTo(x + Math.sin(angle)*size, y + Math.cos(angle)*size);
						for(let i = 1; i < angles; i++){
							angle += Math.PI*2 / angles;
							ctx.lineTo(x + Math.sin(angle)*size, y + Math.cos(angle)*size);
						}
						ctx.fill();
						ctx.closePath();
					},
					end:null,
				},
                {
					name:"Multi Angle Start",
                    init: [
                        {name:"Inner Radius", type:"number", min: 0.05, max: 1, step: 0.05, default:0.05},
                        {name:"angle count", type:"number", min: 3, max: 100, step:1, default:3},
                        {name:"shape angle", type:"number", min: -360, max: 360, step:1, default:0},
                    ],
					begin: null,
					move: function(ctx, x, y, size){
                        let innerRadius = parseFloat(this.init[0].value || this.init[0].default) * size;
                        let angles = parseInt(this.init[1].value || this.init[1].default)*2;

						ctx.beginPath();
						let angle = -parseInt(this.init[2].value || this.init[2].default) / 180 * Math.PI + Math.PI;
						ctx.moveTo(x + Math.sin(angle)*size, y + Math.cos(angle)*size);
						for(let i = 1; i < angles; i++){
                            let s = (i%2) == 0? size : innerRadius;

							angle += Math.PI*2 / angles;
							ctx.lineTo(x + Math.sin(angle)*s, y + Math.cos(angle)*s);
						}
						ctx.fill();
						ctx.closePath();
					},
					end:null,
				},
                {
					name:"Random Multi Angle Start",
                    init: [
                        {name:"Inner Radius", type:"number", min: 0.05, max: 1, step: 0.05, default:0.05},
                        {name:"angle count", type:"number", min: 3, max: 100, step:1, default:3},
                    ],
					begin: null,
					move: function(ctx, x, y, size){
                        let innerRadius = parseFloat(this.init[0].value || this.init[0].default) * size;
                        let angles = parseInt(this.init[1].value || this.init[1].default)*2;

						ctx.beginPath();
						let angle = Math.random() * Math.PI*2;
						ctx.moveTo(x + Math.sin(angle)*size, y + Math.cos(angle)*size);
						for(let i = 1; i < angles; i++){
                            let s = (i%2) == 0? size : innerRadius;

							angle += Math.PI*2 / angles;
							ctx.lineTo(x + Math.sin(angle)*s, y + Math.cos(angle)*s);
						}
						ctx.fill();
						ctx.closePath();
					},
					end:null,
				},
			];

            static colorPins = [];
            static brushSize = 10;

			static bg = null;
            static paint = null;

            static close(){
                if(Paint.paint) Paint.paint.popup.remove();
                Paint.bg.style.display = "none";
            }
            
            static create(data){
                Paint.close();
                Paint.bg.style.display = "unset";
                return Paint.paint = new Paint(data);
            }

            static init(){
                let bg = Paint.bg = document.createElement("div");
                bg.style.width = bg.style.height = "100%";
                bg.style.position = "absolute";
                bg.style.left = bg.style.top = "0";
                bg.style.display = "none";
				bg.style.background = "#00000055";
                bg.addEventListener("click", ()=>{
                    //Paint.close();
                });
                document.body.appendChild(bg);
            }

			constructor(data){
                this.initStorage();
				this.onFinish = ()=>{};
				document.createElementP("div", {className: "screenCenter"}, (el)=>{
					this.popup = el;
					this.sellectedColor = "#fff";

					el.parentNode.onresize = this.onResize.bind(this);
					el.parentNode.onresize();
					el.style.background = "#555555";

					document.createElementP("div", {className: "paintTopBar"}, (topLayout)=>{
						document.createElementP("button", {innerText:"Save", className:"green"}, (btn)=>{
							btn.addEventListener("click", e=>{this.onSave()})
						}, topLayout);

						document.createElementP("button", {innerText:"Discard Changes", className:"orange"}, (btn)=>{
							btn.addEventListener("click", e=>{this.onDiscard()})
						}, topLayout);
					}, el);
					
					document.createElementP("div", {className:"canvasLayout"}, (layout)=>{
						document.createElementP("canvas", {style:{}, width: 512, height: 512}, (canvas)=>{
							this.canvas = canvas;
							this.canvas.ctx = this.canvas.getContext("2d");
							this.canvas.addEventListener("mousedown", (e)=>{this.onCanvasDown(e);this.isMouseDown = true;})
							this.canvas.addEventListener("mousemove", (e)=>{this.onCanvasMove(e)})
							this.canvas.addEventListener("mouseup", (e)=>{this.onCanvasUp(e);this.isMouseDown = false;})
						}, layout);
						document.createElementP("canvas", {style:{}, width: 512, height: 512}, (canvas)=>{
                            
                            canvas.style.position = "absolute";
                            canvas.style.pointerEvents = "none";
							this.previewCanvas = canvas;
							this.previewCanvas.ctx = this.previewCanvas.getContext("2d");
						}, layout);
					}, el);
					
					document.createElementP("div", {className: "paintToolBar"}, (topLayout)=>{
						document.createElementP("div", {className: "colorPickerLayout"}, (colorPickerLayout)=>{
							let i = 0;
                            for(null; i < 16; i++){
								document.createElementP("button", {className: "colorSlot"}, (btn)=>{
                                    let ii = i;
									btn.value = btn.style.background = Paint.colorPins[i] = Paint.colorPins[i] || "#ffffff";
									btn.addEventListener("click", e=>{this.setBrushColor(e, btn)});
									btn.addEventListener("contextmenu", e=>{this.setPickColor(e, btn, ii)});
								}, colorPickerLayout);
							}
							document.createElementP("input", {className: "colorSlot", type:"color"}, (btn)=>{
								this.colorInput = btn;
								btn.style.width = btn.style.height = "44px";
								btn.addEventListener("input", e=>{this.setBrushColor(e, btn, i)});
                                btn.value = btn.style.background = Paint.colorPins[i] = Paint.colorPins[i] || "#000000";
								//btn.value = "#ffffff";
							}, colorPickerLayout);
						}, topLayout);
						document.createElementP("div", {className: "colorPickerLayout"}, (colorPickerLayout)=>{
                            this.brushLayount = colorPickerLayout;
							let first = null;
							for(let i in Paint.brushes){
								document.createElementP("canvas", {className: "colorSlot"}, (btn)=>{
									if(i == "0") first = btn;
									btn.title = Paint.brushes[i].name;
									btn.brush = Paint.brushes[i];
									btn.value = "#fff";
									btn.width = btn.height = 22;
									btn.addEventListener("click", e=>{this.setBrushType(e, btn)});

									let ctx = btn.getContext("2d");
									
									ctx.clearRect(0,0, btn.width, btn.height);
									if(btn.brush.begin) btn.brush.begin(ctx, btn.width/2, btn.height/2, btn.width/2 - 2);
                                    else btn.brush.move(ctx, btn.width/2, btn.height/2, btn.width/2 - 2);
								}, colorPickerLayout);
							}
							document.createElementP("canvas", {className: "colorSlot", type:"color"}, (btn)=>{
								this.brushDisplay = btn;
								btn.ctx = btn.getContext("2d");
								btn.style.width = btn.style.height = "44px";
								btn.width = btn.height = 44;
							}, colorPickerLayout);

							document.createElementP("input", {className: "colorSlot", type:"number"}, (btn)=>{
								this.sizeInput = btn;
								btn.style.width = btn.style.height = "44px";
								btn.addEventListener("change", e=>{this.setBrushSize(e, btn)});
								btn.value = Paint.brushSize;
							}, colorPickerLayout);
							if(first) first.click();
						}, topLayout);
					}, el);

				}, document.body);

				if(data && data.img){
					this.canvas.ctx.drawImage(data.img, 0, 0);
				}
                this.storage.add(this.canvas.toDataURL("image/png"));
                this.setBrushColor(null, this.colorInput);
			}

            initStorage(){
                this.storage = new (class Storage{
                    constructor(parent){
                        this.parent = parent;
                        this.fields = [];
                        this.index = -1;
                    }

                    add(field = null){
                        if(!field) return;
                        if(this.index != this.fields.length-1){
                            this.fields.length = this.index+1;
                        }

                        if(!this.fields[this.index] || this.fields[this.index].src != field){
                            let img = new Image();
                            img.src = field;
                            this.fields.push(img);
                            this.index = this.fields.length-1;
                        }
                    }

                    normalIndex(index){return Math.max(Math.min(index, this.fields.length-1), 0)}

                    undo(dir = -1){
                        this.index += dir;
                        this.index = this.normalIndex(this.index);

                        this.parent.canvas.ctx.clearRect(0, 0, this.parent.canvas.width, this.parent.canvas.height);
                        if(this.fields[this.index]) this.parent.canvas.ctx.drawImage(this.fields[this.index], 0,0);
                    }
                })(this);
            }

			onResize(){
				
				let aspecRatio = document.body.clientWidth / document.body.clientHeight;
				let preferedRation = 6 / 4;

				let maxSize = [document.body.clientWidth * 0.8, document.body.clientHeight * 0.8];

				this.popup.style.width = maxSize[0] + "px";
				this.popup.style.height = maxSize[1] + "px";

				if(aspecRatio > preferedRation) this.popup.style.width = maxSize[1] * preferedRation + "px";
				else this.popup.style.height = maxSize[0] / preferedRation + "px";

			}

			onSave(){
				let url = this.canvas.toDataURL("image/png");
				let img = new Image();
				img.src = url;
				img.onload = ()=>{
					this.onFinish(url, img);
				}
                Paint.close();
			}

			onDiscard(){
                Paint.close();
			}
			
			setBrushColor(e, btn, i){
                if(i) Paint.colorPins[i] = btn.value;
				this.brushDisplay.ctx.fillStyle = this.canvas.ctx.fillStyle = this.colorInput.value = this.sellectedColor = btn.value;
			}
			
			setPickColor(e, btn, i){
				e.preventDefault();
				Paint.colorPins[i] = btn.style.background = btn.value = this.colorInput.value;
			}
			
			setBrushType(e, btn){
				let ctx = this.brushDisplay.ctx;
                let same = this.brushType == btn.brush;

                
                if(!same && this.brushType)for(let i in (this.brushType.init || [])){//destruct
                    this.brushType.init[i].el.remove();
                }
                
                this.brushType = btn.brush;
				
				ctx.clearRect(0,0, this.brushDisplay.width, this.brushDisplay.height);
                
                if(btn.brush.begin) this.brushType.begin(ctx, this.brushDisplay.width/2, this.brushDisplay.height/2, this.brushDisplay.width/2 - 2);
                else this.brushType.move(ctx, this.brushDisplay.width/2, this.brushDisplay.height/2, this.brushDisplay.width/2 - 2);
				
                
                if(!same)for(let i in (this.brushType.init || [])){//construct
                    let data = this.brushType.init[i];
                    document.createElementP("input", {className: "colorSlot", type:data.type}, (btn2)=>{
                        btn2.title = data.name;
                        data.el = btn2;
                        btn2.style.width = btn2.style.height = "44px";
                        
                        if("min" in data) btn2.min = data.min;
                        if("max" in data) btn2.max = data.max;
                        if("step" in data) btn2.step = data.step;
                        if("value" in data) btn2.value = data.value;
                        else if("default" in data) btn2.value = data.default;

                        var normalise = (v)=>{
                            if("min" in data) v = Math.max(data.min, parseFloat(v));
                            if("max" in data) v = Math.min(data.max, parseFloat(v));
                            return v;
                        }

                        btn2.addEventListener("input", e=>{data.value = normalise(btn2.value); btn.click()});
                        
                    }, this.brushLayount);
                }
			}

			setBrushSize(e,btn){
				Paint.brushSize = Math.max(0,parseFloat(btn.value));
			}

			onCanvasDown(e){
				if(this.brushType.begin) this.brushType.begin(this.canvas.ctx, e.offsetX, e.offsetY, Paint.brushSize);
				else if(this.brushType.move) this.brushType.move(this.canvas.ctx, e.offsetX, e.offsetY, Paint.brushSize);
			}

			onCanvasMove(e){
                if(this.isMouseDown)
				if(this.brushType.move) this.brushType.move(this.canvas.ctx, e.offsetX, e.offsetY, Paint.brushSize);
                if(this.brushType.preview) this.brushType.preview(this.previewCanvas.ctx, e.offsetX, e.offsetY, Paint.brushSize);
                else {
                    this.previewCanvas.ctx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                    this.previewCanvas.ctx.beginPath();
                    this.previewCanvas.ctx.moveTo(e.offsetX + Paint.brushSize, e.offsetY);
                    this.previewCanvas.ctx.arc(e.offsetX, e.offsetY, Paint.brushSize, 0, Math.PI*2);
                    this.previewCanvas.ctx.lineWidth = 1;
                    this.previewCanvas.ctx.stroke();
                    this.previewCanvas.ctx.closePath();
                }
			}

			onCanvasUp(e){
				if(this.brushType.end) this.brushType.end(this.canvas.ctx, e.offsetX, e.offsetY, Paint.brushSize);
                this.storage.add(this.canvas.toDataURL("image/png"));
			}
		}
		Paint.init();

        const Gifs = new (class Gifs{
            constructor(){
                this.running = false;
                this.storage = [];
                this.fps = 30;
                const container = document.body.querySelector("#gifTools");
                this.title = container.querySelector("[vv='title']");
                (this.beginBtn = container.querySelector("[vv='beginBtn']")).onclick = ()=>{this.onBeginBtn()};
                (this.addBtn = container.querySelector("[vv='add']")).onclick = ()=>{this.onAddFrame()};
                (this.fpsInput = container.querySelector("[vv='fps']")).onchange = ()=>{this.onFps()};
                (this.repeatInput = container.querySelector("[vv='repeatCnt']")).onchange = ()=>{this.onRepeatCnt()};
                (this.saveBtn = container.querySelector("[vv='save']")).onclick = ()=>{this.onSave()};
            }

            onBeginBtn(){
                this.storage = [];
                this.title.innerText = "Gif (0)";
            }

            onAddFrame(){
                this.storage.push(saveImage(false));
                this.title.innerText = `Gif (${this.storage.length})`;
            }

            onFps(){this.fps = Math.max(Math.min(this.fpsInput.value, 60), 1);}
            onRepeatCnt(){this.repeatCnt = Math.max(this.repeatInput.value, 0);}

            onSave(){
                var encoder = new GIFEncoder();
                encoder.setRepeat(this.repeatCnt);
                encoder.setDelay(1000/this.fps);
                encoder.start();
                
                for(let i = 0; i < this.storage.length; i++){
                    encoder.addFrame(this.storage[i]);
                }
                encoder.finish();
                let fname = (filename || ("tiles-" + Date.now())).split(".");

                encoder.download(`${fname.slice(0,Math.max(1, fname.length-1)).join(".")}.gif`);
            }
        })()
        /*
        var encoder = new GIFEncoder();
        encoder.setRepeat(0);
        encoder.setDelay(1000/30);
        encoder.start();
        ...
        encoder.addFrame(saveImage(false))
        ...
        encoder.finish();
        let fname = (filename || ("tiles-" + Date.now())).split(".");

        encoder.download(`${fname.slice(0,Math.max(1, fname.length-1)).join(".")}.gif`);
        */

        document.addEventListener("keydown", (e)=>{
            if(Paint.paint){
                if(e.code == "KeyU"){
                    Paint.paint.storage.undo(-1);
                }
                if(e.code == "KeyI"){
                    Paint.paint.storage.undo(1);
                }
            }else
            if(document.activeElement.tagName.toLowerCase() == "body"){
                if(e.code == "KeyU"){
                    saves.undo(-1);
                }
                if(e.code == "KeyI"){
                    saves.undo(1);
                }
            }
        })
        function hexToHSL(H) {
            // Convert hex to RGB first
            let r = 0, g = 0, b = 0;
            if (H.length == 4) {
                r = "0x" + H[1] + H[1];
                g = "0x" + H[2] + H[2];
                b = "0x" + H[3] + H[3];
            } else if (H.length == 7) {
                r = "0x" + H[1] + H[2];
                g = "0x" + H[3] + H[4];
                b = "0x" + H[5] + H[6];
            }
            // Then to HSL
            r /= 255;
            g /= 255;
            b /= 255;
            let cmin = Math.min(r,g,b),
                cmax = Math.max(r,g,b),
                delta = cmax - cmin,
                h = 0,
                s = 0,
                l = 0;

            if (delta == 0)
                h = 0;
            else if (cmax == r)
                h = ((g - b) / delta) % 6;
            else if (cmax == g)
                h = (b - r) / delta + 2;
            else
                h = (r - g) / delta + 4;

            h = Math.round(h * 60);

            if (h < 0)
                h += 360;

            l = (cmax + cmin) / 2;
            s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
            s = +(s * 100).toFixed(1);
            l = +(l * 100).toFixed(1);

            return [h,s,l,"hsl(" + h + "," + s + "%," + l + "%)"];
        }

        function HSLToHex(h,s,l) {
            if(h < 0) h = 360-Math.abs(h)
            s /= 100;
            l /= 100;

            let c = (1 - Math.abs(2 * l - 1)) * s,
                x = c * (1 - Math.abs((h / 60) % 2 - 1)),
                m = l - c/2,
                r = 0,
                g = 0, 
                b = 0; 

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }
            // Having obtained RGB, convert channels to hex
            r = Math.round((r + m) * 255).toString(16);
            g = Math.round((g + m) * 255).toString(16);
            b = Math.round((b + m) * 255).toString(16);

            // Prepend 0s, if necessary
            if (r.length == 1)
                r = "0" + r;
            if (g.length == 1)
                g = "0" + g;
            if (b.length == 1)
                b = "0" + b;

            return "#" + r + g + b;
        }
        window.onbeforeunload = function() {
            return "Data will be lost if you leave the page, are you sure?";
        };
        addColor(document.getElementById("colors"))

        function toggleClass(el, cl){
            if(el?.classList){
                if(el.classList.contains(cl)){
                    el.classList.remove(cl)
                    return false;
                }else{
                    el.classList.add(cl)
                    return true;
                }
            }
            return false;
        }

        function copyToClipboard(res){
            const cs = document.createElement("div");
            cs.innerHTML = `<input id="copy-sellector2" value="nop" style="position:absolute; left:-100%; width:10px; border:none;">`;
            document.body.appendChild(cs);
            sellector = cs.childNodes[0];
            
            sellector.value = res;
            sellector.select();
            document.execCommand('copy');
            cs.remove();
            return res;
        }

        setInterval(()=>{redrawTiles()},2000)
    </script>
</body>
</html>